[{"content":"Centos搭建GitLab+Jenkins+SonarQube实现CI/CD 注：该教程可以将服务部署成功，但是在测试项目时，编写jenkinsfile总是会因为插件找不到而出错，暂未解决这个问题\njenkins的jenkinsfile只使用了打印简单语句作为测试。\n添加git仓库，并提交代码，能够实现触发jenkins流程，而且能够运行成功\n因为SonarQube插件已经安装，但是jenkinsfile总显示找不到，未能连调成功\n1. 前提条件 1.1 硬件与系统要求 阿里云 ECS 实例： 规格：至少 4 核 CPU、8 GB 内存、50 GB SSD 磁盘（推荐 16 GB 内存以确保性能）。 操作系统：CentOS 8（最新版本，截至 2025 年 6 月仍支持）。 网络： 公网 IP（绑定到 ECS 实例）。 安全组规则：开放以下端口： 22（SSH） 80（HTTP，GitLab） 443（HTTPS，GitLab） 8080（Jenkins） 9000（SonarQube） 账户与权限： 阿里云账户（已购买 ECS 实例）。 具有 root 权限的用户。 工具： 本地电脑安装 SSH 客户端（如 PuTTY 或终端）。 浏览器（推荐 Chrome）。 2. 环境准备 2.1 创建并配置 ECS 实例 登录阿里云控制台（https://ecs.console.aliyun.com）。 点击“创建实例”，选择： 地域：选择靠近你的区域（如华东 1）。 实例类型：ecs.c6.large（4 vCPU，8 GiB 内存）。 镜像：CentOS 8（公共镜像）。 存储：50 GB SSD 云盘。 网络：分配公网 IP，带宽按需（建议 5 Mbps）。 配置安全组： 创建新安全组，添加规则： 1 2 3 4 5 6 协议类型 | 端口范围 | 授权对象 TCP | 22 | 0.0.0.0/0 TCP | 80 | 0.0.0.0/0 TCP | 443 | 0.0.0.0/0 TCP | 8080 | 0.0.0.0/0 TCP | 9000 | 0.0.0.0/0 设置实例密码或上传 SSH 密钥对，记录密码/密钥。 确认配置，点击“创建实例”，等待实例启动（约 2-5 分钟）。 2.2 连接 ECS 实例 获取实例公网 IP（如 47.100.123.456）。 使用 SSH 客户端连接： 1 ssh root@47.100.123.456 输入密码或使用密钥登录，成功后进入 CentOS 终端。 2.3 更新系统并安装基础工具 更新系统包： 1 2 yum update -y yum upgrade -y 安装常用工具： 1 yum install -y curl wget vim git 2.4 安装 Java 安装 OpenJDK 17\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 yum clean all yum makecache yum install -y epel-release yum update -y yum upgrade -y yum install -y libstdc++ glibc gcc gcc-c++ # 使用yum方式安装jdk sudo yum install -y java-17-openjdk java-17-openjdk-devel # 如果上面的yum方式安装失败，则使用下面的下载文件方式进行安装 # 下载 OpenJDK 17 二进制包 wget https://download.java.net/java/GA/jdk17.0.2/dfd4a8d0985749f896bed50d7138ee7f/8/GPL/openjdk-17.0.2_linux-x64_bin.tar.gz # 解压并安装 sudo mkdir -p /usr/lib/jvm sudo tar -xzf openjdk-17.0.2_linux-x64_bin.tar.gz -C /usr/lib/jvm # 设置环境变量 sudo tee /etc/profile.d/java.sh \u0026lt;\u0026lt;EOF export JAVA_HOME=/usr/lib/jvm/jdk-17.0.2 export PATH=\\$PATH:\\$JAVA_HOME/bin EOF source /etc/profile.d/java.sh # 验证安装 java -version # 预期输出 openjdk version \u0026#34;17.0.2\u0026#34; 2022-01-18 OpenJDK Runtime Environment (build 17.0.2+8-86) OpenJDK 64-Bit Server VM (build 17.0.2+8-86, mixed mode, sharing) 3. 安装 GitLab 3.1 安装依赖 安装必要依赖包： 1 2 3 yum install -y policycoreutils-python-utils openssh-server postfix systemctl enable sshd postfix systemctl start sshd postfix 3.2 添加 GitLab 仓库并安装 添加 GitLab 官方仓库：\n1 curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash 安装 GitLab 社区版（CE）： 安装 GitLab CE 并配置。\n1 sudo yum install -y gitlab-ce 配置 GitLab 编辑 GitLab 配置文件，设置外部 URL（替换 your_domain.com 为你的域名或服务器 IP）。\n1 sudo vim /etc/gitlab/gitlab.rb 修改以下行：\n1 EXTERNAL_URL=\u0026#34;http://your_domain.com\u0026#34; 重新配置并启动 GitLab：\n1 2 sudo gitlab-ctl reconfigure sudo gitlab-ctl start 3.3 访问 GitLab 打开浏览器，访问 http://your_domain.com。 首次访问会提示设置 root 用户密码，记录密码。 登录后，创建新项目（例如 test-project）用于测试。 root的默认密码是在/etc/gitlab/initial_root_password文件中 3.4 创建测试项目 登录 GitLab，点击“Create a project” \u0026gt; “Create blank project”。 设置项目名称（如 test-project），可见性为“Private”，点击“Create project”。 记录项目 HTTP URL（如 http://your_domain/root/test-project.git）。 生成 SSH 密钥（在本地电脑）： 1 2 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; cat ~/.ssh/id_rsa.pub 复制公钥。 在 GitLab 中添加 SSH 密钥： 进入 Profile \u0026gt; Preferences \u0026gt; SSH Keys，粘贴公钥，点击“Add key”。 4. 安装 SonarQube 4.1 安装 PostgreSQL SonarQube 需使用 PostgreSQL 数据库（社区版不支持 MySQL）。\n注：本教程中使用的sonarqube 10版本，需要postgresql起码9.3版本，这里直接使用14的版本进行部署\n安装 PostgreSQL： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 添加 PostgreSQL 官方 Yum 仓库 sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm # 安装 PostgreSQL（推荐版本 14 或更高） sudo yum install -y postgresql14 postgresql14-server postgresql14-libs postgresql14-contrib # 初始化数据库 sudo /usr/pgsql-14/bin/postgresql-14-setup initdb # 启动并启用 PostgreSQL 服务 systemctl enable postgresql-14 systemctl start postgresql-14 # 切换到postgres用户下，为postgres用户修改数据库密码，因为下面会将pg的配置文件修改为md5的模式，如果没有修改密码，则无法登陆 su - postgres psql alter user postgres wiht password \u0026#39;newpassword\u0026#39;; \\q # 将配置文件中method列修改为md5模式，修改完毕后保存并退出 # 例如 # 修改前： local all all peer # 修改后： local all all md5 vim /var/lib/pgsql/14/data/pg_hba.conf # 重新加载配置文件信息 sudo systemctl reload postgresql # 测试新密码，如果连接成功，则代表ok psql -U postgres -h localhost -W 配置 PostgreSQL： 1 2 3 4 5 6 7 su - postgres psql CREATE USER sonar WITH ENCRYPTED PASSWORD \u0026#39;sonar123\u0026#39;; CREATE DATABASE sonarqube OWNER sonar; GRANT ALL PRIVILEGES ON DATABASE sonarqube TO sonar; \\q exit 4.2 安装 SonarQube 下载并解压 SonarQube 社区版（截至 2025 年 6 月，最新版本为 10.x）：\n1 2 3 4 5 6 # 将下载下来的SonarQube解压缩到/opt目录下 cd /opt wget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-10.0.0.68432.zip yum install -y unzip unzip sonarqube-10.0.0.68432.zip mv sonarqube-10.0.0.68432 sonarqube 配置 SonarQube：\n编辑 conf/sonar.properties： 1 vim /opt/sonarqube/conf/sonar.properties 添加/修改以下内容： 1 2 3 4 5 sonar.jdbc.username=sonar sonar.jdbc.password=sonar123 sonar.jdbc.url=jdbc:postgresql://localhost:5432/sonarqube?useUnicode=true\u0026amp;characterEncoding=utf8 sonar.web.host=0.0.0.0 sonar.web.port=9000 创建 SonarQube 用户并设置权限：\n1 2 3 groupadd sonar useradd -g sonar -d /opt/sonarqube sonar chown -R sonar:sonar /opt/sonarqube 配置系统参数：\n1 2 3 4 5 echo \u0026#34;vm.max_map_count=262144\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf echo \u0026#34;fs.file-max=65536\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf sysctl -p echo \u0026#34;sonarqube - nofile 65536\u0026#34; \u0026gt;\u0026gt; /etc/security/limits.conf echo \u0026#34;sonarqube - nproc 4096\u0026#34; \u0026gt;\u0026gt; /etc/security/limits.conf 设置 SonarQube 服务\nSonarQube服务不能使用root身份进行启动，需要切换到sonar普通用户进行启动，但是在启动前需要将SonarQube服务所在的目录权限和所属用户，切换给sonar用户\n1 2 3 4 5 6 7 sudo chown -R sonar:sonar /opt/sonarqube sudo chmod -R 755 /opt/sonarqube su - sonar cd /opt/sonarqube ./bin/linux-x86-64/sonar.sh start # 如果此处启动失败，就去看下sonarqube/logs目录下的日志信息 访问 SonarQube：\n浏览器打开 http://your_domain.com:9000。 默认登录：用户名 admin，密码 admin。 设置新密码（如 admin123）。 创建项目：\n点击“Create Project” \u0026gt; “Manually”。 项目名称：test-project，项目键：test-project，分支：master。 生成 Token（如 sonar-token-123），记录以供 Jenkins 使用。 5. 安装 Jenkins 5.1 添加 Jenkins 仓库 安装最新版本的 Jenkins（长期支持版，免费）。\n1 2 sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 安装 Jenkins 安装 Jenkins 及其依赖\n1 sudo yum install -y jenkins 启动 Jenkins 启动并设置 Jenkins 开机自启。\n1 2 sudo systemctl start jenkins sudo systemctl enable jenkins 配置 Jenkins 访问 http://your_domain.com:8080。 获取初始管理员密码： 1 sudo cat /var/lib/jenkins/secrets/initialAdminPassword 按照界面提示完成安装，建议安装推荐插件。 创建管理员账户。 安装必要插件 在 Jenkins 仪表盘：\n进入 Manage Jenkins \u0026gt; Manage Plugins。\n安装以下插件：\nGitLab Plugin：用于 GitLab 集成。 SonarQube Scanner：用于 SonarQube 扫描。 Pipeline：支持流水线功能。 Git：支持 Git 仓库操作。 配置全局工具：\n进入 Manage Jenkins \u0026gt; Global Tool Configuration。\nJDK：添加 JDK，名称 JDK11，取消“Install automatically”，设置 JAVA_HOME=/usr/lib/jvm/java-11-openjdk。\nMaven：添加 Maven，名称 Maven3，勾选“Install automatically”。\nSonarQube Scanner：添加 Scanner，名称 SonarScanner，勾选“Install automatically”。\n配置 SonarQube 服务器：\n进入 Manage Jenkins \u0026gt; Configure System \u0026gt; SonarQube servers。\n添加：\n名称：SonarQube 服务器 URL：http://your_domain.com:9000 服务器认证 Token：添加凭据，类型“Secret text”，粘贴 SonarQube 的 Token（如 sonar-token-123）。 6. 配置 CI/CD 流水线 6.1 准备测试项目 如果没有安装maven可以到官网下载，这里以Linux版本为例，下载安装maven 3.9.10\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1、下载meave源代码 wget https://dlcdn.apache.org/maven/maven-3/3.9.10/binaries/apache-maven-3.9.10-bin.tar.gz # 解压并安装： 解压到 /usr/local 目录 sudo tar -zxvf apache-maven-3.9.10-bin.tar.gz -C /usr/local/ sudo ln -s /usr/local/apache-maven-3.9.10 /usr/local/maven # 配置环境变量： 编辑 ~/.bashrc 文件，添加 Maven 到 PATH echo \u0026#39;export M2_HOME=/usr/local/maven\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PATH=$M2_HOME/bin:$PATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc # 验证安装，应返回类似 Apache Maven 3.9.10 的信息。代表安装成功 mvn --version 在本地创建 Maven 项目： 1 2 mvn archetype:generate -DgroupId=com.example -DartifactId=test-project -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false cd test-project 配置 pom.xml，添加 SonarQube 插件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;project\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;test-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.sonarsource.scanner.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;sonar-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.9.1.2184\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 推送代码到 GitLab： 1 2 3 4 5 git init git add . git commit -m \u0026#34;Initial commit\u0026#34; git remote add origin http://47.100.123.456/root/test-project.git git push -u origin master 6.2 配置 GitLab Webhook 在 GitLab 项目中：\n进入 Settings \u0026gt; Integrations。 添加 Webhook： URL：http://your_domain:8080/project/test-job 触发事件：勾选“Push events”。 点击“Add webhook”。 1 2 3 # 备注：如果上面的url显示无效或者是使用错误，可以使用下面格式的 # 前面是jenkins的管理员账户和token，后面是jenkins的项目地址 http://admin:119cd07f8d572e0bcb832608efb20fce6e@8.138.235.28:8081/project/test-job 测试 Webhook：\n点击“Test” \u0026gt; “Push events”，确保返回 200 OK。 6.3 创建 Jenkins Pipeline 在 Jenkins 中： 点击“New Item”，名称 test-job，选择“Pipeline”。 配置 Pipeline： General：勾选“GitLab Connection”，选择默认连接。\nBuild Triggers：勾选“Build when a change is pushed to GitLab”。\nPipeline：选择“Pipeline script”，输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 pipeline { agent any tools { maven \u0026#39;Maven3\u0026#39; jdk \u0026#39;JDK17\u0026#39; sonarQubeScanner \u0026#39;SonarScanner\u0026#39; } environment { GIT_CREDENTIALS = \u0026#39;gitlab-credentials\u0026#39; SONAR_SERVER = \u0026#39;SonarQube\u0026#39; DEPLOY_SERVER = \u0026#39;deploy-server\u0026#39; } stages { // 阶段1：从Gitlab 拉取代码 stage(\u0026#39;Checkout\u0026#39;) { steps { git branch: \u0026#34;${params.gitlabBranch ?: \u0026#39;master\u0026#39;}\u0026#34;, credentialsId: \u0026#39;gitlab-credentials\u0026#39;, url: \u0026#39;http://ip/username/xxx.git\u0026#39; // 替换 } } // 阶段2: 编译代码 stage(\u0026#39;Build\u0026#39;) { steps { sh \u0026#39;mvn clean package\u0026#39; } } // 阶段3：SonarQube 代码质量分析 stage(\u0026#39;SonarQube Scan\u0026#39;) { steps { withSonarQubeEnv(\u0026#39;SonarQube\u0026#39;) { sh \u0026#39;mvn sonar:sonar \\ -Dsonar.projectKey=test-project \\ -Dsonar.host.url=http://IP:9000 \\ -Dsonar.login=$SONAR_TOKEN\u0026#39; } } } // 阶段4：检查 SonarQube Quality Gate stage(\u0026#39;Quality Gate\u0026#39;) { steps { timeout(time: 2, unit: \u0026#39;MINUTES\u0026#39;) { waitForQualityGate abortPipeline: true } } } // 阶段5: 部署 stage(\u0026#39;Deploy\u0026#39;) { steps { sh \u0026#39;echo \u0026#34;Deploying Successful, but this is a test demo\u0026#34;\u0026#39; // 示例：scp target/*.jar user@server:/path } } } post { always { cleanWs() } success { echo \u0026#39;Build and deployment completed successfully!\u0026#39; } failure { echo \u0026#39;Build or deployment failed. Check logs for details.\u0026#39; } } } 替换 SONAR_TOKEN 为 SonarQube Token 的 Jenkins 凭据 ID。\n保存并点击“Build Now”测试。 6.4 配置 SonarQube 报告回写 在 SonarQube 中安装 GitLab 插件： 进入 Administration \u0026gt; Marketplace，搜索“GitLab”，安装并重启。 配置 GitLab 集成： 进入 Administration \u0026gt; Configuration \u0026gt; General Settings \u0026gt; GitLab。 设置 GitLab URL（http://your_domain.com/api/v4）和 Personal Access Token（在 GitLab 的 Profile \u0026gt; Access Tokens 生成）。 在项目中启用报告回写： 进入项目设置，启用“Comment on Merge Requests”。 7. 测试流水线 修改本地 test-project 的代码（如 src/main/java/com/example/App.java），提交并推送： 1 2 3 git add . git commit -m \u0026#34;Update code\u0026#34; git push origin master 验证： 在 Jenkins 中，检查 test-job 是否自动触发构建。 在 SonarQube 中，访问 http://47.100.123.456:9000/dashboard?id=test-project，确认代码扫描结果。 在 GitLab 中，检查提交是否收到 SonarQube 的质量报告评论。 若部署阶段配置了服务器，检查目标服务器上的应用是否更新。 8. 常见问题与调试 8.1 GitLab 无法访问 现象：浏览器显示“502 Bad Gateway”。\n解决：\n1 2 gitlab-ctl reconfigure gitlab-ctl restart 检查端口占用：\n1 netstat -tulnp | grep 80 8.2 SonarQube 启动失败 现象：日志（/opt/sonarqube/logs/sonar.log）显示数据库连接错误。\n解决：\n确认 PostgreSQL 运行： 1 systemctl status postgresql 验证 sonar.properties 中的数据库配置。 8.3 Jenkins Webhook 不触发 现象：GitLab 推送无反应。\n解决：\n确认 Jenkins URL 可从 GitLab 访问： 1 curl http://47.100.123.456:8080 检查 GitLab Webhook 日志，确认 HTTP 状态码。 8.4 LFS 文件未显示 若涉及大文件（如你的 125 MB 文件）： 1 2 3 4 5 git lfs install git lfs track \u0026#34;*.pdf\u0026#34; git add .gitattributes git commit -m \u0026#34;Add LFS tracking\u0026#34; git push origin master ","date":"2025-06-28T12:00:00+08:00","image":"https://dxjxpr.github.io/p/centos%E6%90%AD%E5%BB%BAgitlab-jenkins-sonarqube%E5%AE%9E%E7%8E%B0ci/cd/cover_hu_cca79f31c051396.png","permalink":"https://dxjxpr.github.io/p/centos%E6%90%AD%E5%BB%BAgitlab-jenkins-sonarqube%E5%AE%9E%E7%8E%B0ci/cd/","title":"Centos搭建GitLab+Jenkins+SonarQube实现CI/CD"},{"content":"Python的多继承 Python的多继承是指一个类可以同时继承多个父类，从而获得多个父类的属性和方法。这是Python面向对象的一个重要特性，提供了灵活性和代码复用性，但也可能带来复杂性和潜在的问题（如菱形继承问题）\n什么是多继承 多继承是指一个子类可以继承多个父类的特性。Python支持多继承，这意味着一个类可以从多个基类继承属性和方法。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Parent1: def method1(self): print(\u0026#34;Parent1 method1\u0026#34;) class Parent2: def method2(self): print(\u0026#34;Parent2 method2\u0026#34;) class Child(Parent1, Parent2): pass child = Child() child.method1() # 输出Parent1的方法 child.method2() # 输出Parent2的方法 在上面的例子中，Child类继承了Parent1和Parent2，因此Child的实例可以调用两个父类的方法。\n多继承的语法 在Python中，定义多继承的类时，只需要类定义时将多个父类列在括号中，用逗号分隔\n1 2 class Child(Parent1, Parent2, Parent3): pass 父类可以是任意数量（理论上），但实际开发中应谨慎使用，避免过于复杂的继承关系 子类会继承所有父类的属性和方法（包括实例方法、类方法、静态方法等） 方法解析顺序（MRO） 当一个类继承多个父类时，如果父类中有同名方法，Python需要决定调用哪个方法。这是由MRO（Method Resolution Order，方法解析顺序）决定\nMRO的工作原理\nPython使用C3线性算法（C3 Linearization）来确定方法解析顺序。C3算法确保\n子类优先于父类 父类的定义顺序（即类定义时括号中父类的顺序）会影响优先级 避免违反继承的逻辑顺序 可以通过类属性__mro__或方法mro()查看类的MRO。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class A: def method(self): print(\u0026#34;A method\u0026#34;) class B: def method(self): print(\u0026#34;B method\u0026#34;) class C(A, B): pass # (\u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) print(C.__mro__) c = C() # A method c.method() 解释：\nMRO顺序为C-\u0026gt;A-\u0026gt;B-\u0026gt;object 当调用c.method()时，Python按MRO顺序查找method，找到A中的method并执行 如何查看MRO\n使用类名.__mro__：返回一个元组，包含MRO的类顺序 使用类名.mro()：返回一个列表，效果类似 菱形继承问题 多继承可能导致的经典问题是菱形继承问题，即多个父类继承自同一个基类，导致方法解析的复杂性。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class A: def method(self): print(\u0026#34;A method\u0026#34;) class B(A): def method(self): print(\u0026#34;B method\u0026#34;) class C(A): def method(self): print(\u0026#34;C method\u0026#34;) class D(B, C): pass d = D() # B method d.method() # (\u0026lt;class \u0026#39;__main__.D\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.B\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.C\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;__main__.A\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) print(D.__mro__) 解释\nD继承了B和C，而B和C都继承了A，形成了菱形 根据MRO，Python优先查找B的方法，因此调用B.method C3算法确保A只被解析一次，避免重复调用 使用super()处理多继承 在多继承中，super()用于调用父类的方法。super()会根据MRO顺序调用下一个类的方法，而不是直接调用某个特定的父类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A: def method(self): print(\u0026#34;A method\u0026#34;) class B: def method(self): print(\u0026#34;B method\u0026#34;) super().method() class C(A): def method(self): print(\u0026#34;C method\u0026#34;) super().method() class D(B, C): def method(self): print(\u0026#34;D method\u0026#34;) super().method() d = D() d.method() # D method # B method # C method # A method 解释\nsuper()根据MRO顺序依次调用父类方法 MRO为D-\u0026gt;B-\u0026gt;C-\u0026gt;A-\u0026gt;object，因此方法按此顺序执行 注意\n使用super()时，确保所有父类和子类的方法签名一样，否则可能引发参数不匹配的错误 在多继承中，super()的行为依赖MRO，可能不直接调用你期望的父类 多继承的优缺点 优点\n代码复用：可以从多个父类继承功能，减少重复代码 模块化设计：通过组合多个父类的功能，构建复杂的行为 灵活性：适合实现复杂的类层结构 缺点\n复杂性：多继承可能导致代码难以理解和维护 命名冲突：多个父类可能有同名方法，需通过MRO或显式调用解决 菱形继承问题：可能导致意外的行为，需要仔细设计MRO 调试困难：MRO和super()的行为可能不直观，增加调试复杂度 最佳实践 尽量减少多继承\n如何可以用组合（将对象作为属性）替代多继承，优先选择组合 例如：与其让类继承多个父类，不如将功能封装为对象并在类中调用 明确MRO\n在设计多继承时，检查__mro__确保方法解析顺序符合预期 避免复杂的继承层级，保持简单清晰 使用super()正确\n确保所有相关类的方法签名一样 在多继承中，父类应调用super()以支持协作调用 避免命名冲突\n父类方法命名应尽量避免重叠，或在子类中显式指定调用哪个父类的方法（如Parent1.method(self)） 文档化\n为复杂的多继承结构添加注释，说明每个类的作用和MRO顺序 其他 目前只有C++和Python是支持类的多继承，但是需要处理潜在的复杂性，其他的语言基本只支持单继承\n总结 Python多继承允许一个类继承多个父类的属性和方法，提供了高度的灵活性 MRO（基于C3线性化算法）决定了方法解析的顺序 多继承可能导致复杂性（如菱形继承问题），需要谨慎设计 使用super()或显式调用父类方法来处理继承关系 优先考虑组合而非多继承，保持代码清晰简洁 ","date":"2025-06-24T12:00:00+08:00","image":"https://dxjxpr.github.io/p/python%E5%A4%9A%E7%BB%A7%E6%89%BF/cover_hu_116f6f24416ce493.png","permalink":"https://dxjxpr.github.io/p/python%E5%A4%9A%E7%BB%A7%E6%89%BF/","title":"Python多继承"},{"content":"当前文章并非博客，是为了记录这个目录下的阿里云部署openstak的文章，保存为目录，以后有机会了再来重新尝试部署和重新整理这个博客\n","date":"2025-06-23T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E9%9D%9Eblog%E5%8D%95%E7%BA%AF%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/cover_hu_5407237d5ba7f3cd.png","permalink":"https://dxjxpr.github.io/p/%E9%9D%9Eblog%E5%8D%95%E7%BA%AF%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/","title":"非Blog，单纯记录文档"},{"content":"单例模式（Singleton Pattern）是设计模式中一种创建型模式，广泛应用于软件开发中。一以下以故事化的方式，结合详细的技术讲解，介绍单例模式的背景、定义、适用场景，并提供python的示例代码。\n故事1:皇帝的玉玺 在古代的龙国，皇帝是国家的唯一最高统治者，象征权力的玉玺也只有一块。无论多少大臣、多少事务需要盖章，所有人都必须使用同一块玉玺。皇帝下令：这块玉玺是独一无二的，不能有第二块！谁敢私自造玉玺，格杀勿论！ 于是，为了确保玉玺的唯一性，皇帝派专人保管，任何人需要盖章时，都得向保管者申请使用这块玉玺。这样，全国上下都用同一块玉玺，保证了权力的统一性和一致性。 有一天，邻国的使者来访，带来了一个问题：如果多个大臣同时需要盖章，玉玺如何分配？皇帝想了想，决定让保管者记录玉玺的使用情况，确保每次只有一个人能拿到玉玺使用，其他人必须排队等待。这不仅保证了玉玺的唯一行，还避免了混乱。\n这个故事中的玉玺，就是单例模式的完全体现：全局唯一、受控访问。\n故事2:智慧之井 在古代的一个小村庄里，有一口古老的“智慧之井”，据说井水能赋予饮用者无穷的智慧。村民们都想喝到井水，但村长发现，如果每个人都随意打水，井水很快就会干涸。于是，村长宣布：全村只能有一个“水官”负责管理井水，每天只打一桶水，供大家享用。这个“水官”就是全村唯一的井水管理者，任何时候只有他能接触到井水，确保井水不会被滥用。\n这个故事就像程序设计中的单例模式。在软件开发中，有些资源（如数据库连接、配置文件、线程池等），就像“智慧之井”，如果每次都创建新实例，会浪费资源或导致冲突。单例模式就像村里的“水官”，确保全局只有一个实例，统一管理资源。\n单例模式是什么？ 单例模式（Singleton Pattern）是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式的核心是控制对象的创建过程，确保系统中该类的对象始终只有一个。\n解决什么样的问题 单例模式主要解决以下问题：\n1、资源共享：避免多次创建对象导致的资源浪费（如数据库连接池、日志对象）\n2、全局状态管理：需要一个全局唯一的对象来协调系统行为（如配置管理器、计数器）\n3、控制并发访问：防止多个实例同时操作同一资源导致的数据不一致（如线程池）\n4、减少系统开销：避免频繁创建和销毁对象，提升性能\n适用场景 单例模式适用于以下场景\n1、需要全局唯一实例的资源\n配置文件管理器：整个应用共享同一份配置 日志记录器：统一管理日志输出 数据库连接池：避免重复创建连接 2、需要控制资源访问\n线程池：统一管理线程资源 缓存管理器：全局共享缓存数据 3、需要全局协调的场景\n计数器：记录系统中某些操作的次数 状态管理器：维护系统的全局状态 优缺点 优点： 节省资源：只创建一个实例，减少内存和系统开销 全局访问点：提供统一的访问入口，方便管理 严格控制实例：避免多实例带来的冲突或数据不一致 缺点 单点故障：如果单例对象出现问题，可能影响整个系统 难以测试：单例的全局状态可能导致单元测试复杂化 违反单一职责原则：单例既负责自身逻辑，又负责实例管理 扩展性差：难以继承或修改，因为单例通常是静态的 实现方式 单例模式有几种常见实现方式\n饿汉式：类加载时酒创建实例（线程安全，但可能浪费资源） 懒汉式：需要时才创建实例（需考虑线程安全） 双检锁：懒汉式的线程安全优化 静态内部类：结合饿汉式和懒汉式的优点（Java常用） 模块级单例：Python的模块天然支持单例 Python示例代码 以下展示几种Python实现单例模式的方式，并附上详细注释，为了贴合故事，代码以“皇帝的玉玺”作为类名\n方式1:经典懒汉式（线程不安全） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class ImperialSeal: # 私有类变量，存储唯一实例 _instance = None def __new__(cls): # 如果实例不存在，则创建 if cls._instance is None: cls._instance = super().__new__(cls) return cls._instance def __init__(self): # 出事话只执行一次，防止重复初始化 if not hasattr(self, \u0026#39;_initialized\u0026#39;): self._initialized = True self.seal_name = \u0026#34;Dragon Seal\u0026#34; def use_seal(self): print(f\u0026#34;Using the {self.seal_name} to stamp a decree!\u0026#34;) # 测试代码 if __name__ == \u0026#34;__main__\u0026#34;: seal1 = ImperialSeal() seal2 = ImperialSeal() # True print(f\u0026#34;Same instance: {seal1 is seal2}\u0026#34;) # Using the Dragon Seal to stamp a decree! seal1.use_seal() 说明\nnew方法控制实例创建，确保只有一个实例 init适用_initialized防止重复初始化_ 缺点：多线程环境下可能创建多个实例（线程不安全） 方式2:线程安全的懒汉式（使用锁） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import threading from threading import Lock class ImperialSeal: # 私有类变量，存储唯一实例 _instance = None # 锁，用于线程安全 _lock = Lock() def __new__(cls): with cls._lock: if cls._instance is None: cls._instance = super().__new__(cls) return cls._instance def __init__(self): if not hasattr(self, \u0026#39;_initialized\u0026#39;): self._initialized = True self.seal_name = \u0026#34;Dragon Seal\u0026#34; def use_seal(self): print(f\u0026#34;Using the {self.seal_name} to stamp a decree!\u0026#34;) def create_seal(): seal = ImperialSeal() print(f\u0026#34;Created seal: {id(seal)}\u0026#34;) # 测试代码 if __name__ == \u0026#34;__main__\u0026#34;: threads = [threading.Thread(target=create_seal) for _ in range(5)] for t in threads: t.start() for t in threads: t.join() seal1 = ImperialSeal() seal2 = ImperialSeal() # True print(f\u0026#34;Same instance: {seal1 is seal2}\u0026#34;) # Using the Dragon Seal to stamp a decree! seal1.use_seal() 说明\n使用threading.Lock确保多线程环境下之创建一次实例 with cis.lock保证线程安全，但加锁可能影响性能 适合多线程场景，如web服务器中的全局配置管理 方式3:Python模块单例 Python的模块本身是天然的单例，因为模块只加载一次。以下展示如何利用模块实现单例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 单例模式 - 模块级单例实现 # 通过在模块级别定义全局唯一实例来实现单例模式 class ImperialSeal: def __init__(self): self.seal_name = \u0026#34;Dragon Seal\u0026#34; # 玉玺名称 def use_seal(self): print(f\u0026#34;使用 {self.seal_name} 盖章于圣旨！\u0026#34;) # 使用玉玺盖章 # 定义全局唯一实例 seal = ImperialSeal() # 测试代码 if __name__ == \u0026#34;__main__\u0026#34;: # 直接引用模块中的 seal 实例，模拟多次导入 seal1 = seal seal2 = seal print(f\u0026#34;是否为同一实例: {seal1 is seal2}\u0026#34;) # 应输出 True seal1.use_seal() # 输出: 使用 Dragon Seal 盖章于圣旨！ 说明\nPython模块在程序运行期间只加载一次，seal变量天然全局唯一 简单高效，无需显式控制实例创建 适合简单场景，但不适合需要复杂初始化逻辑的情况 故事续篇：玉玺的挑战 龙国的玉玺管理逐渐复杂，大臣们发现\n并发问题：多个大臣同时申请玉玺，导致盖章混乱（线程安全问题） 测试麻烦：玉玺的全局性让模拟测试变的困难（单例的全局状态问题） 扩展需求：邻国提议联合使用玉玺，但玉玺无法轻易扩展（单例扩展性差） 皇帝召集智囊团，决定\n使用“锁匠”（线程锁）确保玉玺一次只被一人使用（线程安全单例） 编写“玉玺副本”用于测试（依赖注入替换单例） 对于新需求，考虑“多玉玺模式”（非单例设计） 这个故事告诉我们：单例模式虽然简单有效，但需谨慎使用，避免滥用导致维护困难\n适用场景举例 1、日志管理器：全局唯一的日志对象，确保日志写入一致\n1 2 3 import logging # logging 模块天然单例 logger = logging.getLogger(\u0026#34;app\u0026#34;) 2、数据库连接池\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pymysql class DBConnection: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super().__new__(cls) cls._instance.conn = pymysql.connect(host=\u0026#34;localhost\u0026#34;, user=\u0026#34;root\u0026#34;, password=\u0026#34;123456\u0026#34;, database=\u0026#34;test\u0026#34;) return cls._instance 3、配置管理：全局读取配置，避免重复加载\n1 2 3 4 5 6 7 class Config: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super(Config, cls).__new__(cls) cls._instance.settings = {\u0026#34;api_key\u0026#34;: \u0026#34;12345\u0026#34;, \u0026#34;timeout\u0026#34;: 30} return cls._instance 注意事项 线程安全：多线程环境下，有限适用锁或模块级单例 测试问题：单例的全局状态可能影响单元测试，建议结合依赖注入 滥用风险：不宜将所有全局对象都用单例，可能导致单例过多，增加复杂性 Python特性：Python的模块机制天然支持单例，优先考虑模块级单例以简化代码 ","date":"2025-06-22T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/cover_hu_ba41686f69864592.png","permalink":"https://dxjxpr.github.io/p/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"单例模式"},{"content":"备注：该教程无法搭建，暂且记录在本博客当中，日后条件够了再搭建 原因 1、Mistral-7B大模型语言，采用4-bit量化，但是需要使用最新版本的bitstandbyte模块，然而这个模块在macos上最新支持到0.42版本，当前（2025.06.28）最新的版本是0.46，但是只有win和linux上的版本，没有macos的版本，故无法继续安装\n2、不采用4-bit量化模型，但是在运行的时候，需要分配很大的内存或者显存缓冲区，但是本电脑性能不足，无法分配，故无法运行成功\n3、如果采用云服务器的方式，如果达到可用的性能标准的时候，云服务器价格过于昂贵，不太现实，所以暂时无法进行搭建\n当前模型的搭建问题先进行遗留，日后条件成熟时，组装一个性能比较不错的电脑再进行搭建\n在2019款MacBook Pro上从零搭建Mistral 7B模型教程 本教程指导你在MacBook Pro（2019款，2.3GHz Intel Core i9，32GB RAM，512GB SSD，Radeon Pro 5500M）上搭建Mistral 7B模型，支持推理、微调（优化中文任务）和联网功能。教程使用开源工具（如Hugging Face、LangChain），适配Intel架构硬件。\n前提条件 硬件：MacBook Pro 2019（16英寸，2.3GHz 8核Intel Core i9，32GB RAM，512GB SSD，Radeon Pro 5500M）。 操作系统：macOS Ventura或Sequoia（建议更新至最新版本以优化性能）。 网络：稳定互联网连接，用于下载软件、模型和数据集。 技能：基础Python编程、终端操作知识；初学者可能需额外学习（教程包含入门指引）。 存储：512GB SSD可存储模型（~5-10GB）和小型数据集（~10-50GB），建议外接1TB SSD（约800-1500元）以扩展存储。 成本：500-2000元（含外接SSD和可能的云端GPU租用，如AWS g5.4xlarge，1-2美元/小时）。 目标 推理：本地运行Mistral 7B，响应时间1-5秒。 微调：优化模型支持中文任务（如问答、文本生成）。 联网：通过LangChain集成联网功能（如搜索、API调用）。 时间估算：单人初学者约1-2周（推理1-3天，微调5-10天，联网1-2天）。 步骤 1：环境搭建 1.1 安装Homebrew Homebrew是macOS的包管理器，用于简化软件安装。\n打开终端（应用程序 \u0026gt; 实用工具 \u0026gt; 终端）。 安装Homebrew： 1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 验证安装： 1 brew --version 预期输出：Homebrew 4.x.x。 下载地址：Homebrew官网 https://brew.sh/\n1.2 安装Python 3.10+ Mistral 7B需要Python 3.10或更高版本。\n安装Python： 1 brew install python@3.10 验证Python版本： 1 python3 --version 预期输出：Python 3.10.x。 确保pip可用： 1 2 python3 -m ensurepip --upgrade python3 -m pip --version 下载地址：Homebrew自动从Python官方源下载 https://www.python.org/\n1.3 安装必要库 安装PyTorch、Hugging Face Transformers等核心库。Intel Mac不支持MPS（Metal Performance Shaders），依赖CPU或AMD GPU。\n安装PyTorch（CPU版，Radeon Pro 5500M支持有限）： 1 python3 -m pip install torch==2.2.0 安装Hugging Face Transformers、PEFT（用于LoRA微调）、Datasets和LangChain： 1 python3 -m pip install transformers==4.38.2 peft==0.10.0 datasets==2.18.0 langchain==0.1.16 安装bitsandbytes（用于4-bit量化，降低内存占用）： 1 python3 -m pip install bitsandbytes==0.43.0 验证安装： 1 python3 -c \u0026#34;import torch, transformers, peft, langchain; print(\u0026#39;All libraries installed\u0026#39;)\u0026#34; 下载地址：\nPyTorch: https://pytorch.org/ Hugging Face Transformers: https://huggingface.co/docs/transformers/installation LangChain: https://python.langchain.com/docs/get_started/installation 1.4 安装Git和Jupyter（可选） Git用于克隆代码库，Jupyter便于调试。\n安装Git： 1 2 brew install git git --version 安装Jupyter： 1 python3 -m pip install jupyter 启动Jupyter： 1 jupyter notebook 浏览器会打开Jupyter界面（http://localhost:8888）。 下载地址：\nGit: https://git-scm.com/ Jupyter: https://jupyter.org/install 时间估算：1-2天（初学者可能需学习终端和Python环境配置）。\n步骤 2：下载Mistral 7B模型 2.1 获取模型权重 Mistral 7B是开源模型，可从Hugging Face下载。\n访问Hugging Face模型页面：https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1（注：Mixtral 8x7B为Mistral 7B的增强版，单7B版本可通过mistralai/Mistral-7B-v0.1获取）。 克隆模型仓库（需安装git lfs）： 1 2 3 brew install git-lfs git lfs install git clone https://huggingface.co/mistralai/Mixtral-8x7B-Instruct-v0.1 ~/mistral-7b 模型权重（~14GB，未量化）存储在~/mistral-7b。若硬盘空间不足，建议外接1TB SSD。 2.2 量化模型 使用4-bit量化降低内存占用（从14GB降至5-8GB）。\n使用bitsandbytes加载量化模型（后续代码中实现）。 验证模型大小： 1 du -sh ~/mistral-7b 下载地址：Hugging Face模型库 https://huggingface.co/\n时间估算：1-2小时（视网络速度）。\n步骤 3：本地推理Mistral 7B 3.1 编写推理代码 以下是使用Hugging Face Transformers运行Mistral 7B的Python脚本。\n创建文件infer_mistral.py： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from transformers import AutoModelForCausalLM, AutoTokenizer import torch # 加载模型和分词器 model_name = \u0026#34;mistralai/Mixtral-8x7B-Instruct-v0.1\u0026#34; tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoModelForCausalLM.from_pretrained( model_name, load_in_4bit=True, # 4-bit量化 device_map=\u0026#34;auto\u0026#34; # 自动分配设备（CPU/GPU） ) # 输入提示 prompt = \u0026#34;你好！请用中文回答：今天是星期几？\u0026#34; inputs = tokenizer(prompt, return_tensors=\u0026#34;pt\u0026#34;) # 生成输出 outputs = model.generate(**inputs, max_length=50) response = tokenizer.decode(outputs[0], skip_special_tokens=True) print(response) 运行脚本： 1 python3 infer_mistral.py 预期输出：类似“今天是星期四”（基于2025年6月12日）。 3.2 优化推理 内存管理：4-bit量化确保内存占用\u0026lt;10GB，适合32GB RAM。 性能：Intel i9和Radeon Pro 5500M支持CPU推理，响应时间~1-5秒。 问题排查：若内存不足，检查bitsandbytes是否正确安装，或减小max_length。 下载地址：\nVS Code（代码编辑器）：https://code.visualstudio.com/\n时间估算：1-2天（包括调试和优化）。 步骤 4：微调Mistral 7B（优化中文任务） 4.1 获取中文数据集 使用开源中文数据集（如BELLE）进行微调。\n下载BELLE数据集（~10GB，需硬盘空间）： 1 git clone https://github.com/LianjiaTech/BELLE ~/belle-data 选择子集（如BELLE-0.5M），约1-2GB，适合512GB SSD。 预处理数据（格式化为JSONL）： 1 2 3 from datasets import load_dataset dataset = load_dataset(\u0026#34;BelleGroup/BELLE-0.5M\u0026#34;) dataset[\u0026#34;train\u0026#34;].to_json(\u0026#34;belle_data.jsonl\u0026#34;) 下载地址：BELLE数据集 https://huggingface.co/datasets/BelleGroup/BELLE-0.5M\n4.2 使用LoRA微调 LoRA（低秩适配）降低微调内存需求。\n编写微调脚本finetune_mistral.py： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from transformers import AutoModelForCausalLM, AutoTokenizer, TrainingArguments, Trainer from peft import LoraConfig, get_peft_model from datasets import load_dataset # 加载模型和分词器 model_name = \u0026#34;mistralai/Mixtral-8x7B-Instruct-v0.1\u0026#34; tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoModelForCausalLM.from_pretrained(model_name, load_in_4bit=True) # 配置LoRA lora_config = LoraConfig( r=16, # 秩 lora_alpha=32, target_modules=[\u0026#34;q_proj\u0026#34;, \u0026#34;v_proj\u0026#34;], lora_dropout=0.05 ) model = get_peft_model(model, lora_config) # 加载数据集 dataset = load_dataset(\u0026#34;json\u0026#34;, data_files=\u0026#34;belle_data.jsonl\u0026#34;) def tokenize_function(examples): return tokenizer(examples[\u0026#34;instruction\u0026#34;], truncation=True, max_length=512) tokenized_dataset = dataset.map(tokenize_function, batched=True) # 配置训练参数 training_args = TrainingArguments( output_dir=\u0026#34;./mistral-finetuned\u0026#34;, per_device_train_batch_size=1, gradient_accumulation_steps=4, num_train_epochs=1, save_steps=100, logging_steps=10 ) # 训练 trainer = Trainer( model=model, args=training_args, train_dataset=tokenized_dataset[\u0026#34;train\u0026#34;] ) trainer.train() # 保存模型 model.save_pretrained(\u0026#34;./mistral-finetuned\u0026#34;) tokenizer.save_pretrained(\u0026#34;./mistral-finetuned\u0026#34;) 运行微调： 1 python3 finetune_mistral.py 验证微调效果（重用推理脚本，加载./mistral-finetuned）。 4.3 微调优化 内存：LoRA+4-bit量化将内存占用控制在~10-15GB，32GB RAM可行。 硬盘：微调输出（checkpoints）约10-20GB，需确保空间充足。 性能：Intel i9支持微调，但速度较慢（~1-2小时/epoch，视数据集大小）。 云端辅助（可选）：若微调太慢，租用AWS EC2 g5.4xlarge（NVIDIA A10 GPU，~1-2美元/小时），加速至数小时。 时间估算：5-10天（数据准备2-5天，微调和测试3-5天）。\n步骤 5：实现联网功能 5.1 使用LangChain集成联网 LangChain支持Mistral 7B通过API或工具（如SerpAPI）实现联网搜索。\n安装SerpAPI（用于联网搜索）： 1 python3 -m pip install google-search-results 获取SerpAPI密钥： 注册SerpAPI：https://serpapi.com/ 获取API密钥（免费试用50次搜索/月，付费约50美元/月）。 编写联网脚本mistral_with_internet.py： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from langchain import HuggingFacePipeline, LLMChain from langchain.prompts import PromptTemplate from langchain.tools import Tool from langchain.agents import initialize_agent, AgentType from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline from serpapi import GoogleSearch # 加载Mistral模型 model_name = \u0026#34;./mistral-finetuned\u0026#34; # 使用微调后的模型 tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoModelForCausalLM.from_pretrained(model_name, load_in_4bit=True) pipe = pipeline(\u0026#34;text-generation\u0026#34;, model=model, tokenizer=tokenizer, max_length=200) llm = HuggingFacePipeline(pipeline=pipe) # 定义搜索工具 def search(query): params = {\u0026#34;q\u0026#34;: query, \u0026#34;api_key\u0026#34;: \u0026#34;YOUR_SERPAPI_KEY\u0026#34;} # 替换为你的API密钥 search = GoogleSearch(params) return str(search.get_dict().get(\u0026#34;organic_results\u0026#34;, [])) search_tool = Tool(name=\u0026#34;GoogleSearch\u0026#34;, func=search, description=\u0026#34;Search Google for information\u0026#34;) # 初始化代理 agent = initialize_agent( tools=[search_tool], llm=llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True ) # 测试联网问答 query = \u0026#34;今天的天气如何？\u0026#34; response = agent.run(query) print(response) 替换YOUR_SERPAPI_KEY，运行脚本： 1 python3 mistral_with_internet.py 预期输出：类似“根据搜索结果，今天[你的城市]的天气是\u0026hellip;”。 下载地址：\nSerpAPI: https://serpapi.com/ LangChain: https://python.langchain.com/docs/ 5.2 优化联网功能 API限制：SerpAPI免费版限额低，建议测试后升级付费计划。 响应时间：联网查询增加1-2秒延迟，整体仍\u0026lt;5秒。 替代方案：若不使用SerpAPI，可集成免费API（如Wikipedia API），但信息覆盖有限。 时间估算：1-2天（配置LangChain和API）。\n步骤 6：测试与部署 6.1 测试模型 测试推理： 1 python3 infer_mistral.py 输入中文提示（如“介绍北京的天气”），验证响应质量。 测试联网： 1 python3 mistral_with_internet.py 输入动态查询（如“2025年最新科技趋势”），确认联网结果。 截图占位：显示推理和联网脚本的终端输出。\n6.2 部署优化 本地部署：将推理脚本封装为命令行工具或Web界面（使用Streamlit）：\n1 python3 -m pip install streamlit 创建app.py：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import streamlit as st from transformers import AutoModelForCausalLM, AutoTokenizer import torch st.title(\u0026#34;Mistral 7B Chatbot\u0026#34;) model_name = \u0026#34;./mistral-finetuned\u0026#34; tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoModelForCausalLM.from_pretrained(model_name, load_in_4bit=True) prompt = st.text_input(\u0026#34;输入你的问题：\u0026#34;) if st.button(\u0026#34;生成回答\u0026#34;): inputs = tokenizer(prompt, return_tensors=\u0026#34;pt\u0026#34;) outputs = model.generate(**inputs, max_length=200) response = tokenizer.decode(outputs[0], skip_special_tokens=True) st.write(response) 运行：\n1 streamlit run app.py 访问http://localhost:8501。\n下载地址：Streamlit https://streamlit.io/\n6.3 问题排查 内存不足：确保4-bit量化生效，关闭后台程序。 硬盘满：清理~/mistral-7b和~/mistral-finetuned中的临时文件，或使用外接SSD。 推理慢：减小max_length或优化batch size。 联网失败：检查SerpAPI密钥和网络连接。 时间估算：1-2天（测试和部署）。\n时间与成本估算 总时间：1-2周（初学者） 环境搭建：1-2天 模型下载和推理：1-3天 微调：5-10天 联网功能：1-2天 测试与部署：1-2天 加速建议： 有Python/ML经验可缩短至1周。 使用云端GPU（如AWS，1-2天微调）可节省时间。 成本： 硬件：外接1TB SSD（800-1500元，推荐SanDisk或Samsung）。 软件：免费（Python、PyTorch、Hugging Face、LangChain）。 API：SerpAPI免费试用，付费50美元/月（约350元）。 云端（可选）：AWS EC2 g5.4xlarge（1-2美元/小时，微调约50-100美元）。 总计：500-2000元。 注意事项 硬盘管理：定期清理checkpoints（rm -rf ./mistral-finetuned/checkpoint-*），优先使用外接SSD。 性能优化：Intel i9和Radeon Pro 5500M适合推理，微调可能慢，考虑云端。 社区资源：参考Hugging Face教程 https://huggingface.co/docs、LangChain文档 https://python.langchain.com/docs/。 法律合规：Mistral 7B为开源模型（Apache 2.0许可），使用BELLE数据集需遵守其许可。 总结 通过本教程，你可以在2019款MacBook Pro上成功搭建Mistral 7B模型，支持本地推理（1-5秒响应）、中文任务微调和联网功能（通过LangChain和SerpAPI）。总耗时1-2周，成本500-2000元，适合初学者和小型应用开发。若需进一步优化或更大规模任务，考虑云端GPU支持。\n","date":"2025-06-18T12:00:00+08:00","image":"https://dxjxpr.github.io/p/macos-%E4%B8%8A%E6%90%AD%E5%BB%BAmistral-7b%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%99%E7%A8%8B/cover_hu_4f9f3e9fbcc2ab51.jpg","permalink":"https://dxjxpr.github.io/p/macos-%E4%B8%8A%E6%90%AD%E5%BB%BAmistral-7b%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%99%E7%A8%8B/","title":"MacOS 上搭建Mistral-7B大模型教程"},{"content":"git cherry-pick命令 定义\n用于将指定的提交(commit)从一个分支\u0026quot;挑选\u0026quot;并应用到当前分支 它复制某个提交的更改（diff），生成一个新的提交，保留原提交的更改内容，但拥有新的提交ID（SHA值） 命令\n1 git cherry-pick \u0026lt;commit-id\u0026gt; 核心功能\n提取单个或多个提交的更改，应用到目标分支 不影响分支的整体历史，仅复制指定提交 适合修复bug、移植特性或整理提交 适用场景\n需要从一个分支移植一个特定更改到另一个分支时非常有用 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 假设有以下分支 # main分支有提交A、B、C。 # feature分支从B分叉，包含提交D、E、F。 A---B---C (main) \\ D---E---F (feature) # 现在将feature分支的提交E（例如一个Bug修复）应用到main，但不想要D或F。 # 首先切换到main分支 git switch main # git checkout main # 然后执行cherry-pick，选择提交E（假设E的SHA值为e123456） # 如果无冲突，Git会在main分支创建一个新提交E\u0026#39;，包含E的更改 git cherry-pick e123456 # 提交后的结果 A---B---C---E\u0026#39; (main) \\ D---E---F (feature) # 如果有冲突，提示错误信息，如下 error: could not apply e123456... [commit message] # 手动解决冲突，解决完成后 git add \u0026lt;file\u0026gt; # 继续cherry-pick git cherry-pick --continue # 或者放弃cherry-pick git cherry-pick --abort 批量cherry-pick\n1 2 3 4 5 # 挑选多个提交（如E和F） git cherry-pick e123456 f789012 # 或指定范围（从D到F，不包括D） git cherry-pick D..F 优点\n精准选择 只引入特定提交，避免不需要的更改，灵活性高 适合移植bug修复或特定功能 独立操作 不影响源分支或整体历史，仅在当前分支生成新提交 便于协作 可快速将关健修复从开发分支应用到生产分支 简单直观 相比merge和rebase，操作单一，易于理解和执行 缺点\n手动挑选成本高 需要知道具体提交的SHA值或范围，手动操作繁琐 不适合大量提交的整合 冲突处理复杂 如果cherry-pick的提交依赖其他未挑选的提交，可能导致冲突或功能不完整 冲突需手动解决，多次cherry-pick可能重复处理类似冲突 历史重复 cherry-pick生成新提交，可能导致代码重复（若后续合并源分支） 例如：E\u0026rsquo;和E可能在在未来合并时造成冲突 丢失上下文 只复制提交内容，丢失原提交的完整分支上下文，调试或追溯可能困难 适用场景\n修复bug 将开发分支的bug修复快速应用到生产分支 移植特性 将特性分支的某些功能引入其他分支（如实验性功能） 清理历史 挑选关键提交，整理分支历史，结合rebase适用 临时整合 在合并整个分支前，测试特定提交的效果 与merge和rebase对比\nvs merge merge整合整个分支，保留历史（快进线性或非快进线性） cherry-pick只选特定提交，适合精细控制 vs rebase rebase重放整个分支历史，生成线性历史 cherry-pick只重放指定提交，操作更局部 git stash命令 定义 用于临时保存工作目录和索引（暂存区）的更改，并将工作目录恢复到最近一次提交的状态（干净状态） 它将未提交的更改（包括已跟踪文件的修改和暂存的更改）存储到一个栈（stash stack）中，供后续恢复或应用 命令 git stash 核心功能 保存未提交的更改（工作目录和暂存区） 清理工作目录，恢复到最近的提交状态 允许稍后恢复或应用保存的更改到当前或其他分支 目的 避免提交临时更改：在切换分支、拉取代码或执行其他操作时，临时保存未完成的工作 保持工作目录干净：确保工作目录无未提交更改，便于git操作（如合并、变基） 灵活管理更改：支持多次stash，随时恢复或丢弃 功能与命令 保存更改 保存工作目录和暂存区的更改到stash栈 默认保存已跟踪文件的修改（包括暂存和未暂存更改） 恢复工作目录 将工作目录和暂存区恢复到最近提交的状态 恢复更改 将工作目录和暂存区恢复到最近提交的状态 恢复更改 从stash栈中恢复保存的更改到当前分支 管理stash 查看、应用、删除或清理stash记录 常用命令 保存更改\n1 2 3 4 5 6 git stash # 默认保存更改，命名为stash@{n}(n为栈索引，从0开始) # 添加描述 git stash push -m \u0026#39;message\u0026#39; 保存未跟踪文件，包含未跟踪文件（如新文件)\n1 git stash -u 保存所有文件，包含未跟踪和忽略文件。\n1 git stash -a 查看stash列表\n1 2 3 4 5 git stash list # 显示所有stash记录，例如 stash@{0}: WIP on feature: abc1234 Add feature X stash@{1}: On main: def5678 Temp changes 应用stash\n1 2 3 git stash apply # 应用最新stash（stash@{0}），保留stash记录 git stash apply stash@{1} 应用并删除stash\n1 2 git stash pop # 应用最新stash并从栈中移除 删除stash\n1 2 git stash drop stash@{1} # 删除指定stash 清理所有stash\n1 git stash clear 优点\n灵活性 快速保存和恢复未提交更改，无需创建临时提交 支持多次stash，管理多个工作状态 保持干净 清理工作目录，便于切换分支、拉取代码或执行其他git操作 非破坏性 更改安全存储在stash栈，不会丢失（除非手动清理） 跨分支应用 可将stash应用到其他分支，适合移植临时更改 简单易用 命令直观，适合快速上下文切换 缺点\n管理复杂 多个stash可能导致栈混乱，难以记住每个stash的内容 默认命令，如stash@{0}不够直观，需手动添加描述 冲突风险 应用stash时，若当前分支状态不兼容，可能引发冲突，需手动解决 未跟踪文件遗漏 默认不保存未跟踪文件，需显式使用-u或-a，否则可能遗漏 不适合长期存储 stash设计为临时保存，长期依赖可能导致管理混乱，不如提交或分支 调试困难 stash记录仅保存更改差异，缺乏完整提交上下文，追溯可能不便 应用场景\n临时切换分支 在开发特性时，需紧急切换到main修复bug，stash保存未完成的工作 拉取最新的代码 执行git pull前，工作目录有未提交更改，stash清理目录以避免冲突 测试临时更改 测试某些修改后想恢复原始状态，stash保存实验性更改 移植更改 将未提交更改应用到其他分支，类似cherry-pick但针对未提交内容 清理提交历史 在提交前整理工作目录，stash临时更改，调整后再提交 ","date":"2025-05-13T12:00:00+08:00","image":"https://dxjxpr.github.io/p/git-cherry-pick%E5%92%8Cgit-stash%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/cover_hu_e5fc114d678d9c79.png","permalink":"https://dxjxpr.github.io/p/git-cherry-pick%E5%92%8Cgit-stash%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","title":"Git Cherry-pick和Git Stash命令详解"},{"content":"git merge和git rebase 在Git中merge和rebase都是git在管理整合分支的两种主要工具，但是他们的工作方式、提交历史影响和使用场景不同。\ngit merge 定义\n将两个分支的提交历史合并，创建一个新的合并提交（merge commit），保留两个分支的完整历史。但是在快进合并（fast-foward）情况下直接移动指针，保持线性历史 通常是将特性分支（feature branch）合并到主分支（如main分支） 工作原理\nGit首先会找到两个分支的共同祖先节点，计算差异，然后合并代码 如果没有冲突，自动合并 如果有冲突，需要手动解决该冲突后生成合并提交 快进模式：若目标分支无新提交，直接将指针移动到源分支，历史线性。 非快进模式：生成合并提交，历史非线性，保留分支拓扑 示例\n1 2 3 # 将feature分支合并到main分支上 git checkout main git merge feature 快进合并（若main无新提交）\nmain指针移动到feature最新提交，历史线性 非快进合并（默认或指定\u0026ndash;no-ff）\n创建合并提交，历史非线性 提交历史图\n快进合并（线性历史，修正后在一条直线上）\n1 2 3 # 初始：main和feature指向A；feature新增B、C。 # 合并后：main快进到C，历史为单条直线。 A---B---C (main, feature) 非快进合并（非线性历史）\n1 2 3 4 5 6 # 合并后：M为合并提交，指向B和D A---B (main) \\ C---D (feature) \\ M (main, 合并提交) 优点\n快进合并：生成线性历史，干净简单，适合简单整合。\n非快进合并：保留分支历史，反映开发过程，便于追溯。\n团队协作：合并提交记录分支整合，适合多人项目。\n简单冲突处理：冲突集中解决，生成单一提交。\n非破坏性：不改写历史，安全用于共享分支。\n缺点:\n非快进历史复杂：频繁非快进合并导致历史杂乱，合并提交多。 非快进非线性：分支分叉增加历史图复杂度。 快进需条件：仅当目标分支无新提交时快进，否则需手动指定\u0026ndash;ff。 适用场景\n团队开发，保留清晰的历史提交记录 git rebase 定义\n将当前分支的提交\u0026quot;嫁接\u0026quot;到目标分支最新提交上，改写历史，始终生成线性历史 用于清理本地分支或平滑整合提交 工作原理\nGit将当前分支的提交逐一应用到目标分支最新提交，生成新提交（SHA值变化） 冲突需要逐一提交解决，完成后历史性 示例\n1 2 git checkout feature git rebase main 结果：feature的提交重放至main最新提交，历史线性。\n可快进合并到main\n1 2 git checkout main git merge feature 提交历史图示（线性历史）\n1 A---B---C\u0026#39;---D\u0026#39; (main, feature) 初始：main在A，feature有A\u0026mdash;C\u0026mdash;D。\n重放后：feature变为A\u0026mdash;C\u0026rsquo;\u0026mdash;D\u0026rsquo;，main快进到D\u0026rsquo;，历史为单条直线。\n优点\n干净线性历史：历史简洁，易于审查和版本管理。\n简化提交：可整理提交（如git rebase -i合并小提交）。\n便于快进合并：重放后主分支可直接快进。\n适合单人开发：清理本地分支，提升提交质量。\n缺点:\n历史重写：改写提交SHA值，破坏共享分支，影响协作。 冲突复杂：逐提交解决冲突，工作量可能大。 丢失上下文：线性历史隐藏分支来源，追溯困难。 高风险：误操作可能丢失提交。 适用场景\n适合个人开发，可以保留干净的历史提交记录 关键区别 特性 git merge git rebase 历史结构 快进合并：线性；非快进合并：非线性 始终线性 提交记录 快进：无新提交；非快进：合并提交 重写提交，无合并提交 冲突处理 一次性解决所有冲突 逐提交解决冲突 历史清晰度 快进：干净；非快进：保留分支上下文 干净，但丢失分支上下文 使用场景 协作开发，需保留历史或快进合并 单人开发，追求干净历史 ","date":"2025-05-12T12:00:00+08:00","image":"https://dxjxpr.github.io/p/git-merage%E5%92%8Cgit-rebase%E5%8C%BA%E5%88%AB/cover_hu_9f57dc87b8d38057.jpg","permalink":"https://dxjxpr.github.io/p/git-merage%E5%92%8Cgit-rebase%E5%8C%BA%E5%88%AB/","title":"Git Merage和Git Rebase区别"},{"content":"Git基本操作命令 放两张图便于理解 第一张图，是只有本地仓库的相关操作，对文件的增删改、提交、撤销等 第二张图，是将远程仓库包含进来 创建仓库命令 1 2 3 4 # 初始化一个仓库 git init # 从远程服务器上克隆一个仓库，其实也相当于下载一个仓库 git clone 远程仓库的地址 提交与修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 将文件添加到暂存区 # 可以使用通配符，例如：git add *.txt # 可以使用目录，例如：git add . # 表示添加当前目录下已经修改的文件 git add # 查看当前仓库的状态，是否有文件更改 git status # git diff 比较文件的不同，即暂存区和工作区的差异 git diff：比较工作区和暂存区中的文件差异 git diff --cache：比较暂存区和本地仓库的文件差异 git diff HEAD（本地仓库的历史提交ID，此处使用HEAD作为事例）：比较工作区和本地仓库的文件差异 git diff ID1 ID2：比较本地仓库的两个版本之间的差异 # 使用外部差异工具查看和比较文件的更改 git difftool # 比较两个提交范围之间的差异 git range-diff # 提交暂存区中的文件到本地仓库 # 只提交暂存区中的内容，不会提交工作区中的内容 git commit -m \u0026#34;commit message\u0026#34; 提交日志 1 2 3 4 5 6 7 8 9 10 11 12 13 # 查看仓库提交历史记录 # 可以在该命令后添加 --oneline 参数来查看简洁的提交记录 # 更高级的图形化显示参数 --all --graph --oneline --decorate git log # 列表形式查看指定文件的历史修改记录 git blame \u0026lt;file\u0026gt; # 简洁日志摘要 git shortlog # 生成一个可读的字符串 git describe 版本回退 git reset\n三种不同的参数模式 \u0026ndash;soft：表示回退到某一个版本，并且保留工作区和暂存区中所有修改的内容 \u0026ndash;hard：表示回退到某一个版本，并且丢弃工作区和暂存区中所有修改的内容 \u0026ndash;mixed：介于soft和hard之间，表示保留工作区，但是丢弃暂存区中的内容 分支切换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 使用场景：多人协作开发 # 查看分支列表 git branch # 创建分支 git branch branch-name # 切换分支 git checkout branch-name # 更加推荐使用 git switch branch-name # 合并分支 git merge branch-name # 删除分支 git branch -d branch-name # 已合并 git branch -D branch-name # 未合并 删除文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 先从工作区删除文件，然后再将删除的内容添加到暂存区 rm file git add file # 把文件从工作区和暂存区同时删除 git rm file # 把文件从暂存区删除，但保留在当前工作区中 git rm --cached file # 递归删除某个目录下的所有子目录和文件 git rm -r * # 以上操作都需要进行commit提交 .gitignore文件 作用：自动忽略掉不需要被提交到版本库中的文件 日志文件、文件夹 .class文件 .o文件 .env文件 .zip和tar文件 .pem文件 等等 匹配规则 空行或者亿#开头的行会被Git忽略。一般空行用于可读性的分割，#一般用作注释 使用标准的blob模式匹配，例如： 星号**通配任意个自负 问号？匹配单个自负 中括号[]表示匹配列表中的单个字符，比如：[abc]表示a/b/c 两个星号**表示匹配任意的中间目录 中括号可以使用短中线连接，比如： [0-9]表示任意一位数字，[a-z]表示任意一位小写字母 感叹号 ! 表示取反 1 2 3 4 5 6 7 8 9 10 # 忽略所有的.a文件 *.a # 但跟踪所有的lib.a，即便你在前面忽略了.a文件 !lib.a # 忽略任何目录下名位build的文件夹 build/ # 忽略doc/notes.txt，但不忽略/doc/server/arch.txt doc/*.txt # 忽略doc/目录及其所有子目录下的.pdf文件 doc/**/*.pdf 远程操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 远程仓库操作 git remote # 从远程获取代码库 git fetch # 下载远程代码并合并 git pull # 上传远程代码并合并 git push # 管理子仓库 git submodule Git分支管理 关于git分支功能是Git强大的功能之一，可以让多个开发人员协作并行工作，开发新功能、修改bug，并最终汇集到主分支上。每一个分支都代表着一条独立的开发线路。关于git分支管理，有两个工作流模式，一个叫做Gitflow工作流，一个叫做Github工作流\nGitflow工作流（比较复杂，不适合持续集成，适合团队人数较多的情况） 功能分支（Feature）：开发人员以功能名称命名一个分支，独立于其他分支进行开发工作，完成开发后合并入共享开发分支。 共享开发分支（Develop）：用于集成多个功能分支，一个版本全部功能开发完成后，可以拉出发布分支进行发布，而共享开发分支可以继续进行下一个版本的开发工作。 发布分支（Release）：用于保存发布过程中产生的代码修改，发布后会将代码合并到共享开发分支和主分支。 热修复分支（Hotfix）：当某个正式版本出现紧急 bug 需要修复时，从主分支的对应版本拉出 Hotfix 分支，进行紧急修复，发布后，合并回主分支。 主分支（Master）：用于保存所有发布的版本。 Github工作流（相对Gitflow工作流简单，适合团队人数较少的情况） 除了以上两种工作流模式外，还有GitLab Flow工作流。关于工作流模式此处不再详细介绍。\n创建分支 1 2 3 4 5 # 创建新分支并切换到该分支 git checkout -b branch-name # 切换分支 git checkout branch-name 查看分支 1 2 3 4 5 6 7 8 # 查看所有分支 git branch # 查看远程分支 git branch -r # 查看所有本地分支和远程分支 git branch -a 合并分支 1 2 3 4 5 6 # 将其他分支合并到当前分支 git merge branch-name(其他分支名) # 在合并的时候，出现合并冲突的文件，需要手动解决冲突，在解决完冲突后，需要重新提交该冲突文件 git add \u0026lt;confict-file\u0026gt; git commit 删除分支 1 2 3 4 5 6 7 8 # 删除本地分支 git branch -d branch-name # 强制删除未合并的分支 git branch -D branch-name # 删除远程分支 git push origin --delete branch-name 保存当前文件未提交更改并切换分支 1 2 3 4 5 6 # 保存当前工作目录中的未提交更改，并将其恢复到干净的工作区 git stash # 恢复最近保存的更改 git stash pop # 列出所有保存的更改 git stash list Git提交历史 git log 查看历史提交记录 git blame 以列表形式查看指定文件的历史修改记录 命令：git log [选项] [分支名/提交哈希]\n常用的选项包括：\n-p：显示提交的补丁（具体更改内容）。 --oneline：以简洁的一行格式显示提交信息。 --graph：以图形化方式显示分支和合并历史。 --decorate：显示分支和标签指向的提交。 --author=\u0026lt;作者\u0026gt;：只显示特定作者的提交。 --since=\u0026lt;时间\u0026gt;：只显示指定时间之后的提交。 --until=\u0026lt;时间\u0026gt;：只显示指定时间之前的提交。 --grep=\u0026lt;模式\u0026gt;：只显示包含指定模式的提交消息。 --no-merges：不显示合并提交。 --stat：显示简略统计信息，包括修改的文件和行数。 --abbrev-commit：使用短提交哈希值。 --pretty=\u0026lt;格式\u0026gt;：使用自定义的提交信息显示格式。 命令：git blame [选项] \u0026lt;文件路径\u0026gt;\n常用的选项包括：\n-L \u0026lt;起始行号\u0026gt;,\u0026lt;结束行号\u0026gt;：只显示指定行号范围内的代码注释。 -C：对于重命名或拷贝的代码行，也进行代码行溯源。 -M：对于移动的代码行，也进行代码行溯源。 -C -C 或 -M -M：对于较多改动的代码行，进行更进一步的溯源。 --show-stats：显示包含每个作者的行数统计信息。 恢复和回退 Git提供了多种方法来恢复和回退到之前的版本，不同的命令适用于不同的场景和需求\n以下是几种常见的方法\ngit checkout：切换分支或恢复文件到指定提交。 git reset：重置当前分支到指定提交（软重置、混合重置、硬重置）。 git revert：创建一个新的提交以撤销指定提交，不改变提交历史。 git reflog：查看历史操作记录，找回丢失的提交。 1、git checkout：检查出特定版本的文件\ngit checkout 命令用于切换分支或恢复工作目录中的文件到指定的提交\n恢复工作目录中的文件到某个提交\n1 2 # 将filename恢复到commit-id提交时的版本 git checkout \u0026lt;commit-id\u0026gt; -- \u0026lt;filename\u0026gt; 切换到特定提交\n1 git checkout \u0026lt;commit-id\u0026gt; 2、git reset重置当前分支到特定提交\ngit reset命令可以更改当前分支的提交历史，它有三种主要模式：--soft、--mixed、--hard\n\u0026ndash;soft：只重置HEAD到指定的提交，暂存区和工作目录保持不变 1 git reset --soft \u0026lt;commit\u0026gt; \u0026ndash;hard：重置HEAD到指定的提交，暂存区和工作目录都重置 1 git reset --hard \u0026lt;commit\u0026gt; \u0026ndash;mixed：重置HEAD到指定的提交，暂存区重置，但工作目录保持不变 1 git reset --mixed \u0026lt;commit\u0026gt; 3、git revert：撤销某次提交\ngit revert命令创建一个新的提交，用来撤销指定的提交，它不会改变提交历史，适用于已经推送到远程仓库的提交\n1 git revert \u0026lt;commit\u0026gt; 4、git reflog：查看历史操作记录\ngit reflog：命令记录了所有HEAD的移动。即使提交被删除或重置，也可以通过reflog找回\n1 git reflog Git标签 Git标签（Tag）用于给定仓库中的特定提交点加上标记，通常用于发布版本。比如你手里有一个项目完成了第一个阶段的功能，可以标记为v1.0版本，可以使用git tag -a v1.0命令给最新的一次提交打上v1.0的标签\n-a 选项意思为创建一个带注解的标签 标签语法格式如下\n1 git tag tag-name 标签推送 默认情况下，git push不会推送标签，需要显式推送标签\n1 2 3 4 git push origin tag-name # 推送所有标签 git push origin --tags 删除标签 1 2 3 4 5 # 本地删除 git tag -d tag-name # 远程删除 git push origin --delete tag-name 附注标签 附注标签存储了创建的名字、Email等信息，附注更为正式，适用于需要额外元数据的场景\n附注标签语法如下\n1 2 3 4 git tag -a tag-name -m \u0026#34;message\u0026#34; # PGP签名标签命令 git tag -s tag-name -m \u0026#34;message\u0026#34; 查看标签信息 1 git show tag-name 删除标签 1 2 3 4 5 # 本地删除 git tag -d v1.0 # 远程删除 git push origin --delete v1.0 ","date":"2025-05-11T12:00:00+08:00","image":"https://dxjxpr.github.io/p/git%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/cover_hu_532632a7fcbcdda2.jpg","permalink":"https://dxjxpr.github.io/p/git%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","title":"Git初始化相关配置"},{"content":"HTTP方法 HTTP方法（也称HTTP动词）主要用于定义对资源的操作类型。根据HTTP/1.1规范（RFC 7231）以及后续扩展，常用的HTTP方法有以下几种：\nGET：请求获取指定资源的表示形式。 POST：向指定资源提交数据，请求服务器处理（如创建资源）。 PUT：更新指定资源的内容，通常是整体替换。 DELETE：请求删除指定的资源。 HEAD：与GET类似，但只返回响应头，不返回主体内容。 OPTIONS：获取服务器支持的HTTP方法或其他选项。 PATCH：对资源进行部分修改。 TRACE：回显服务器收到的请求，用于测试或诊断（较少使用）。 CONNECT：用于建立到资源的隧道，通常用于代理（如HTTPS）。 说明： 以上9种方法是最常见的，涵盖了RESTful API和Web开发中的主要操作。 实际使用中，GET、POST、PUT、DELETE、PATCH最为频繁。 某些方法（如TRACE、CONNECT）因安全或特定场景限制，使用较少。 HTTP规范允许扩展方法，但非标准方法（如WebDAV的PROPFIND、MKCOL）不常见。\nHTTP状态码（Status Code） HTTP状态码（Status Code）是服务器对客户端请求的响应状态，分为五类，一共约60种标准状态码。\n1xx - 信息性状态码（Informational） 表示请求已经被接收，处理仍然在继续，客户端需等待进一步响应 100 Continue：客户端应继续发送请求的剩余部份。 101 Switching Protocols：服务器根据客户端请求切换协议（如HTTP到WebSocket） 102 Processing：服务器正在处理请求，但尚未完成（较少见） 2xx - 成功状态码（Success） 表示请求已经成功被服务器接收、理解并处理 200 OK：请求成功，响应包含请求的数据 201 Created：请求成功并创建了新资源（如POST请求） 202 Accepted：请求已接收但尚未处理完成（常用于异步处理） 204 No Content：请求成功，但无内容返回（如DELETE请求） 206 Partial Content：服务器成功返回部份内容（常用于范围请求，如视频分片） 3xx - 重定向状态码（Redirection） 表示客户端需采取进一步操作（如重定向）以完成请求 300 Multiple Choices：资源有多种表示形式，客户端需选择 301 Moved Permanently：资源永久移动到新URL 302 Found：资源临时移动到新URL（早期称为：Moved Temporarily） 303 See Other：建议客户端使用GET请求访问另一个URL 304 Not Modified：资源未更改，客户端可使用缓存（常用于条件请求） 307 Temporary Redirect：临时重定向，客户端应保留原请求方法 308 Permanent Redirect：永久重定向，客户端应保留原请求方法 4xx - 客户端错误状态码（Client Error） 表示客户端请求有误，服务器无法处理 400 Bad Request：请求语法错误或参数无效 401 Unauthorized：请求需身份验证（未提供或无效的认证信息） 403 Forbidden：客户端无权限访问资源 404 Not Found：服务器未找到请求的资源 405 Method Not Allowed：请求方法（如POST）不被服务器允许 408 Request Timeout：客户端请求超时 409 Conflict：请求与服务器资源状态冲突（如尝试创建已存在的资源） 410 Gone：资源已被永久删除且无转发地址 429 Too Many Requests：客户端在限定时间内发送了过多请求（限流） 5xx - 服务器错误状态码（Server Error） 表示服务器在处理请求时发生错误 500 Internal Server Error：服务器遇到未知错误，无法完成请求 501 Not Implemented：服务器不支持请求的功能（如不支持的请求方法） 502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应 503 Service Unavailable：服务器暂时不可用（如维护或过载） 504 Gateway Timeout：网关或代理服务器未及时从上游服务器收到响应 505 HTTP Version Not Supported：服务器不支持请求的HTTP协议版本 其他 总数：约60种标准状态码（由HTTP/1.1、HTTP/2及扩展定义），实际使用中常见约20-30种 扩展状态码：某些服务器或框架可能定义非标准状态码（如Cloudflare的520、522），但不属于官方规范 ","date":"2025-05-10T12:00:00+08:00","image":"https://dxjxpr.github.io/p/http%E6%96%B9%E6%B3%95%E7%8A%B6%E6%80%81%E7%A0%81status-code/cover_hu_fe8fc5b0fb1a8bfb.jpg","permalink":"https://dxjxpr.github.io/p/http%E6%96%B9%E6%B3%95%E7%8A%B6%E6%80%81%E7%A0%81status-code/","title":"HTTP方法、状态码（Status Code）"},{"content":"Git配置 在Git安装完成后，windows操作系统上会多出一个Git Bash的软件，如果是linux或者是macOS，那么直接打开终端，在终端中敲击命令即可 1 2 3 4 # 检查git版本 git -v # 或 git --version 在使用git时，需要配置一下用户名和邮箱 1 2 3 4 5 6 7 8 # 用户名 git config --global user.name \u0026#34;your name\u0026#34; # 邮箱 git config --global user.email \u0026#34;your email\u0026#34; # 省略(Local)：本地配置，只对本地仓库有效 # --global：全局配置，所有仓库生效，最多使用 # --system：系统配置，对所有用户生效，一般不使用 以上命令只需要执行一次即可，执行以下命令可以用于保存用户名和密码，执行该命令的主要目的是由于使用http时，会出现一个弹窗要求输入用户名和密码，只需要在第一次clone输入用户名和密码，这些信息就被存储起来，以后就可以自动读取，不需要你在手动输入了。 如果是配置了ssh密钥，那么就可以不用执行这个命令 1 git config --global credential.helper store 查看git的配置信息 1 git config --global --list Git初始化 创建仓库两种方式\n在文件夹下执行git init命令 执行git clone命令从远程服务器上clone一个已经存在的仓库 如果使用git init命令初始化一个仓库，是初始化当前所在目录，如果是执行了git init xxx这样的话，是会在当前目录下创建一个xxx目录，并且初始化为一个git仓库\n可以看到在执行完成git init后，该目录后面多了一个master标识\n出现上面黄色字体的部份，是因为这是Git 2.28 版本之后的新特性。这个提示是在你第一次使用 Git 初始化一个仓库时出现的，它告诉你默认的主分支名称从 master 可能会更改为其他名称（例如 main、trunk 或 development）。 为了防止出现这个警告，你可以通过在命令行中输入以下命令来配置 Git 初始化默认分支名称，个人一般习惯使用master\n1 git config --global init.defaultBranch \u0026lt;name\u0026gt; 执行命令后再次执行git init命令就不会再出现上方黄色字体部份了\n如果已经创建一个仓库，但是想要更改主分支名称，则可以使用以下命令\n1 2 # \u0026lt;name\u0026gt;是你想要更改后的主分支名称 git branch -m \u0026lt;name\u0026gt; 如何才能确定当前文件夹是一个git仓库 除了会在终端命令行后面显示一个master标识外，最重要的就是当前仓库下有一个.git的目录，这个目录一定不能删除，因为一旦删除后，这个目录就不再是一个仓库，也无法查看历史文件了\n工作区、暂存区、本地仓库 工作区（Working Directory）\n本地计算机上的项目目录，在这个目录下创建、修改和删除操作。工作区包含了当前项目的所有文件和子目录 暂存区（Staging Area/Index）\n暂存区是一个临时存储的区域，它包含了即将被提交到版本库中的文件快照，在提交之前，可以选择性的将工作区中的修改添加到暂存区中 本地仓库（Local Repository）\n本地仓库包含了所有的版本历史记录，每一次提交都会在版本库中创建一个新的快照，这些快照是不可更改，具有唯一ID，确保了项目的完整历史记录 三者之间的关系\n工作区\u0026ndash;\u0026gt;暂存区 使用git add命令将工作区中的修改添加到暂存区中 1 2 git add filename # 如果将filename替换成 . 表示将当前目录下的所有变更的文件全部提交到暂存区中 暂存区\u0026ndash;\u0026gt;本地仓库 使用git commit命令将暂存区中的修改提交到版本库 注：该操作不会提交工作区中的文件，只会提交暂存区中的文件 1 git commit -m \u0026#39;current commit message\u0026#39; 本地仓库\u0026ndash;\u0026gt;远程仓库 使用git push命令将本地仓库的提交推送到远程仓库 1 git push origin branch-name 远程仓库\u0026ndash;\u0026gt;本地仓库 使用git pull或git fetch命令从远程仓库获取更新 1 2 3 4 git pull origin branch-name # 或 git fetch origin branch-name git merge origin/branch-name 文件状态\n未跟踪（Untarck）：新创建的文件\n未修改（Unmodified）：已经被git管理的文件\n已修改（Modified）：已经被修改，但是还没有被添加到暂存区的文件\n已暂存（Staged）：已经修改，并且已经添加到暂存区的文件\n","date":"2025-05-09T12:00:00+08:00","image":"https://dxjxpr.github.io/p/git%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/cover_hu_532632a7fcbcdda2.jpg","permalink":"https://dxjxpr.github.io/p/git%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","title":"Git初始化相关配置"},{"content":"HTTP (HyperText Transfer Protocol) 定义：应用层协议，用于通过Web传输数据（如网页、文件） 默认端口：80 机制：客户端发送Get请求，服务器返回文件或数据流，基于请求-响应模型 安全性：数据明文传输，容易被窃听和篡改 下载性能：无加密，传输速度最快，适合大文件下载 HTTPS (HTTP Secure) https是http的加密版本，使用TLS/SSL加密通信 默认端口：443 机制：同HTTP一样，但是通过TLS/SSL加密，确保数据不被拦截或篡改 安全性：数据加密，防止中间人攻击，服务器通过TLS证书验证身份 下载性能：加密增加少量开销（TLS握手），速度略慢于HTTP SSH (Secure Shell) 安全协议，用于远程登陆、命令执行和文件传输 默认端口：22 机制：通过加密回话传输文件，支持SCP/SFTP或Git协议，基于持久连接 安全性：数据全程加密，使用公钥/私钥认证 下载性能：适合小文件或高安全性场景 三者区别对比 特性 HTTP HTTPS SSH 加密性 无加密，明文传输，易被拦截 TLS/SSL 加密，安全 默认加密（RSA/Ed25519），安全 端口 80 443 22 认证方式 无或用户名/密码、Token 同 HTTP，另需服务器 TLS 证书 密码或公钥/私钥认证 下载场景 公开文件、网页内容 安全文件下载、API、Git 仓库 远程文件、Git 仓库、服务器管理 Git 下载 HTTPS URL，需凭证 HTTPS URL，需凭证 SSH URL，密钥认证 速度 快（无加密开销） 略慢（加密开销） 较慢（加密和会话开销） 工具 浏览器、curl、wget 浏览器、curl、wget scp、sftp、Git 连接模型 请求-响应，无状态 请求-响应，无状态 会话式，双向通信 适用性 公开资源下载 安全下载、API 调用 私有资源、需认证的下载 使用ssh-keygen生成密钥对 简介 ssh-keygen是Openssh提供的命令工具，用于生成和管理ssh密钥对，包含 私钥：保密，存储在本地（如~/.ssh/id_rsa） 公钥：可分享，添加到远程服务器或服务（如：~/.ssh/id_rsa.pub） 前提要求 系统要求 Linux/macOS：通常预装OpenSSH（验证：ssh-keygen \u0026ndash;version） Windows：使用Git bash、PowerShell（Windows10/11内置OpenSSH）或WSL 安装OpenSSH（如果未安装） Linux：sudo apt install opens-client（Debian/Ubuntu）或sudo yum install opens-clients（CentOS） macOS：brew install openssh Windows：启用\u0026quot;OpenSSH客户端\u0026quot;或安装Git for Windows 终端基础：熟悉命令行操作即可 生成密钥对 1、打开终端（Linux/macOS终端，windows的Git bash或PowerShell）\n2、执行以下命令\n1 2 3 4 5 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; # -t rsa：算法类型（RSA，也可选 ecdsa 或 ed25519）。 # -b 4096：密钥长度（4096 位更安全，默认 2048 位）。 # -C \u0026#34;your_email@example.com\u0026#34;：添加注释（通常是邮箱，便于识别）。 3、提示输入保存路径，如下所示（一般默认即可，直接回车）\n1 2 3 4 Enter file in which to save the key (/home/user/.ssh/id_rsa): # 默认路径：按 Enter，保存到 ~/.ssh/id_rsa（私钥）和 ~/.ssh/id_rsa.pub（公钥）。 # 自定义路径：输入路径（如 ~/.ssh/my_key），生成 my_key 和 my_key.pub。 4、设置密码\n1 2 3 4 5 6 Enter passphrase (empty for no passphrase): Enter same passphrase again: # 无密码：直接按 Enter，方便自动登录（如 Git 推送），但安全性稍低。 # 设置密码：输入密码，每次使用私钥需输入，适合服务器登录。 # 建议：GitHub 等场景可不设密码，服务器登录建议设密码。 5、确认生成\n1 2 3 4 Your identification has been saved in /home/user/.ssh/id_rsa Your public key has been saved in /home/user/.ssh/id_rsa.pub The key fingerprint is: SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx your_email@example.com 如果是一路回车选择默认操作，那么公钥和私钥所在路径如下\n1 2 3 # ~是Home（家）目录 私钥：~/.ssh/id_rsa 公钥：~/.ssh/id_rsa.pub 其他算法 Ed25519（推荐，现代且高效），操作如下 1 2 3 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 优点：速度快、安全性高。 # 缺点：老系统可能不支持。 ECDSA，操作如下 1 2 ssh-keygen -t ecdsa -b 521 -C \u0026#34;your_email@example.com\u0026#34; # 适合资源受限设备 推荐：优先 Ed25519，若需兼容性用 RSA（4096 位） 将公钥添加到Github 1、登陆Github，进入 Settings \u0026gt; SSH and GPG keys \u0026gt; New SSH key\n2、粘贴公钥，设置标题（如 “MyKey”），点击 Add SSH key即可\n3、测试联通性，执行以下命令\n1 ssh -T git@github.com 会输出以下内容\n1 Hi username! You\u0026#39;ve successfully authenticated... 如果出现以下内容，敲yes回车即可\n1 2 3 The authenticity of host \u0026#39;github.com (222.222.222.222)\u0026#39; can\u0026#39;t be established. # RSA key fingerprint is 66:77:ffc:a5:76:28:55:3g:6h:1b:56:4e:tb:df:gg:g8. # Are you sure you want to continue connecting (yes/no)? 将公钥复制到远程服务器 执行以下命令\n1 2 3 ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote_host # 替换 user@remote_host为你的真实服务器ip地址（如 john@192.168.1.100），添加时需要输入密码 # 或手动将公钥追加到服务器的 ~/.ssh/authorized_keys。 测试联通性，执行以下命令\n1 2 3 4 5 ssh user@remote_host # 若没有密码，则会直接连接成功 # 若设密码，输入私钥密码。 # 如果出现以下内容，敲yes回车即可 # Are you sure you want to continue connecting (yes/no)? ","date":"2025-05-08T12:00:00+08:00","image":"https://dxjxpr.github.io/p/httphttpsssh%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ssh-keygen%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9/cover_hu_e39eeec5880b4377.jpg","permalink":"https://dxjxpr.github.io/p/httphttpsssh%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ssh-keygen%E7%94%9F%E6%88%90%E5%AF%86%E9%92%A5%E5%AF%B9/","title":"HTTP、HTTPS、SSH区别以及如何使用ssh-keygen生成密钥对"},{"content":"Git 简介 Git是一个开源的分布式版本控制系统，跨平台，支持Windows、Linux、MacOS。主要是用于项目的版本管理，是由林纳斯·托瓦兹(Linux Torvalds)在2005年为Linux内核开发而创建。 起因 在2002年至2005年间，Linux内核开发团队使用BitKeeper（一个专有的版本控制系统）来管理代码，Linux团队汇集了全球顶尖人才，免不了有人想破解BitKeeper的软件，BitKeeper的开发公司BitMover在2005年停止了向Linux团队的免费版本支持。 于是成功惹怒了Linus这位大佬，迫使Linus寻找一个高效、分布式的版本控制工具。由于对当时其他工具（如SVN、CVS）的性能和功能不满，Linus决定开发一个自己的版本控制系统，然后一周后，Git这个延续至今的闪耀新星诞生。只能说大佬就是大佬。 站在历史的角度来说，BitKeeper公司也是错过了一次流芳百世的机会/商机，如果BitKeeper公司继续提供使用，可能也不会有Git的问世。历史的滚滚车轮总是这么奇妙，悄无声息，又很神秘，好像一切都是安排好的一样。 设计目标 高效性：能够快速处理大型项目（如Linux内核）的版本控制 分布式：允许开发者在本地操作完整的历史记录，无需依赖中央服务器 数据完整性：通过SHA-1哈希确保版本历史的可靠性 简单易用：提供直观的命令和灵活的工作流程 发展历史 几个关键阶段\n2005年4月7日正式上线\n2005-2008年：社区接管与功能完善\n2008-2012年：普及与生态系统繁荣\n2012-2020年：性能优化与新功能\n2020年至今：现代化与企业级应用\n当今地位 普及度：Git是全球最流行的版本控制系统，几乎所有主流代码托管平台（Github、GitLab、Bitbucket）都是以Git为核心 影响力：Git不仅用于软件开发，还被应用于书籍写作、法律文档管理、数据科学等领域 维护：Git由开源社区进行维护，拥有全球顶尖的开发者贡献者，代码托管在GitHub上 Git下载与安装 官网地址：https://git-scm.com/ GitHub地址：https://github.com/git/git 基本概念 仓库（Repository）：存储代码和版本历史的地方，分为本地仓库和远程仓库。 提交（Commit）：代码变更的快照，记录修改内容和元数据（如作者、时间）。 分支（Branch）：代码的独立开发线，默认分支通常为main。 合并（Merge）：将不同分支的更改整合到一起。 远程仓库（Remote）：托管在服务器上的仓库，如GitHub、GitLab。 常用命令 初始化：git init（创建新仓库） 克隆：git clone （复制远程仓库） 添加：git add （将更改加入暂存区） 提交：git commit -m \u0026ldquo;message\u0026rdquo;（保存更改到本地仓库） 推送：git push origin （上传本地更改到远程仓库） 拉取：git pull（从远程仓库获取更新） 分支：git branch（查看分支）、git checkout -b （创建并切换分支） 合并：git merge （合并分支） 应用场景 软件开发：管理代码版本，支持团队协作。 开源项目：通过GitHub等平台实现全球开发者贡献。 非代码场景：管理文档、配置文件、数据科学项目等。 ","date":"2025-05-07T12:00:00+08:00","image":"https://dxjxpr.github.io/p/git%E7%AE%80%E4%BB%8B-%E5%8F%91%E5%B1%95/cover_hu_7087cbdccea9a9d2.jpg","permalink":"https://dxjxpr.github.io/p/git%E7%AE%80%E4%BB%8B-%E5%8F%91%E5%B1%95/","title":"Git简介-发展"},{"content":"1. ExpressVPN 简介: 以高速、稳定性和强大的隐私保护（无日志、256位加密）著称，支持多平台（Windows、Mac、iOS、Android等）。 服务器数量: 3000+ 服务器 分布情况: 94个国家，覆盖北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（日本、香港、新加坡等）、南美、非洲、澳洲。 优点: 速度快、稳定性高、解锁流媒体（如Netflix）能力强，全球服务器分布均衡。 缺点: 价格较高。 链接: ExpressVPN 2. NordVPN 简介: 提供强大安全性（双重加密、CyberSec防广告），适合流媒体和隐私保护。 服务器数量: 5000+ 服务器 分布情况: 60+国家，主要在北美（美国、加拿大）、欧洲（英国、荷兰、瑞典等）、亚洲（日本、印度、韩国等）、澳洲。 优点: 服务器数量多、安全性强、流媒体解锁效果好。 缺点: 界面略复杂，部分地区速度波动。 链接: NordVPN 3. Surfshark 简介: 性价比高，支持无限设备连接，适合流媒体和预算用户。 服务器数量: 3200+ 服务器 分布情况: 100+国家，包括北美（美国、加拿大）、欧洲（德国、法国、西班牙等）、亚洲（新加坡、印度、香港等）、南美、非洲。 优点: 价格实惠、无设备限制、服务器分布广泛。 缺点: 部分服务器速度稍慢。 链接: Surfshark 4. CyberGhost 简介: 用户友好，专注于流媒体解锁（如Netflix、Disney+），适合初学者。 服务器数量: 9000+ 服务器 分布情况: 100+国家，覆盖北美（美国、加拿大）、欧洲（英国、法国、罗马尼亚等）、亚洲（日本、香港、韩国等）、南美、中东。 优点: 服务器数量庞大、流媒体专用服务器、易用性高。 缺点: 隐私政策透明度稍逊，速度中等。 链接: CyberGhost 5. Private Internet Access (PIA) 简介: 强调隐私保护（开源代码、无日志政策），价格实惠。 服务器数量: 10,000+ 服务器 分布情况: 80+国家，主要在北美（美国、加拿大）、欧洲（英国、德国、瑞士等）、亚洲（日本、澳大利亚、新加坡等）。 优点: 服务器数量最多、价格低、隐私保护强。 缺点: 流媒体解锁能力有限，界面较简陋。 链接: Private Internet Access 6. ProtonVPN 简介: 由ProtonMail团队开发，注重隐私和安全（开源、无日志），适合隐私优先用户。 服务器数量: 4000+ 服务器 分布情况: 80+国家，覆盖北America（美国、加拿大）、欧洲（瑞士、德国、法国等）、亚洲（日本、香港、印度等）、澳洲。 优点: 隐私保护极佳、提供免费计划、服务器质量高。 缺点: 价格偏高，免费计划功能有限。 链接: ProtonVPN 7. VyprVPN 简介: 提供自有服务器和Chameleon协议，注重速度和隐私。 服务器数量: 700+ 服务器 分布情况: 70+国家，包括北美（美国、加拿大）、欧洲（英国、法国、瑞士等）、亚洲（香港、日本、新加坡等）、中东。 优点: 自有服务器安全性高、支持多种协议。 缺点: 服务器数量较少，价格中等。 链接: VyprVPN 8. Mullvad 简介: 极致隐私保护（匿名注册、支持加密货币支付），适合隐私极客。 服务器数量: 800+ 服务器 分布情况: 40+国家，主要在欧洲（瑞典、德国、英国等）、北美（美国、加拿大）、亚洲（日本、香港）、澳洲。 优点: 隐私保护顶尖、价格固定。 缺点: 服务器数量少、流媒体解锁能力弱。 链接: Mullvad 9. IPVanish 简介: 提供快速连接，适合P2P和流媒体，隐私保护较强。 服务器数量: 2200+ 服务器 分布情况: 75+国家，覆盖北美（美国、加拿大）、欧洲（英国、荷兰、西班牙等）、亚洲（日本、印度、新加坡等）。 优点: 速度快、适合P2P。 缺点: 隐私政策曾有争议，流媒体解锁不稳定。 链接: IPVanish 10. TunnelBear 简介: 界面简洁，适合初学者和轻度用户。 服务器数量: 5000+ 服务器 分布情况: 50+国家，包括北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（日本、香港、印度等）、澳洲。 优点: 界面友好、提供免费计划。 缺点: 功能较简单，高级用户需求不足。 链接: TunnelBear 11. Astrill VPN 简介: 提供专有协议，适合高审查地区的高级用户。 服务器数量: 300+ 服务器 分布情况: 60+国家，主要在北美（美国、加拿大）、欧洲（英国、德国、荷兰等）、亚洲（香港、日本、新加坡等）。 优点: 专为高审查地区优化、稳定性好。 缺点: 价格高、服务器数量少。 链接: Astrill VPN 12. StrongVPN 简介: 提供可靠连接和WireGuard协议，适合绕过地理限制。 服务器数量: 950+ 服务器 分布情况: 59个国家，包括北美（美国、加拿大）、欧洲（英国、法国、德国等）、亚洲（日本、香港、新加坡等）。 优点: 支持多种协议、价格合理。 缺点: 服务器数量中等，界面较老旧。 链接: StrongVPN 13. PureVPN 简介: 提供广泛的服务器网络，适合流媒体和多设备使用。 服务器数量: 6500+ 服务器 分布情况: 70+国家，包括北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（香港、日本、韩国等）、中东、非洲。 优点: 服务器数量多、性价比高。 缺点: 隐私政策曾受质疑，速度不稳定。 链接: PureVPN 14. Windscribe 简介: 提供免费和付费计划，适合轻度用户和预算有限者。 服务器数量: 400+ 服务器（付费用户可用更多） 分布情况: 60+国家，包括北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（香港、日本、印度等）。 推荐指数: 7.5/10 优点: 提供免费计划、价格低。 缺点: 服务器数量少、速度一般。 链接: Windscribe 15. Atlas VPN 简介: 注重性价比和流媒体解锁，适合预算用户。 服务器数量: 1000+ 服务器 分布情况: 40+国家，包括北美（美国、加拿大）、欧洲（英国、德国、荷兰等）、亚洲（日本、新加坡、香港等）。 优点: 价格低、流媒体解锁效果好。 缺点: 服务器数量较少、隐私保护中等。 链接: Atlas VPN 16. PrivateVPN 简介: 小型但可靠，注重隐私和流媒体解锁。 服务器数量: 200+ 服务器 分布情况: 60+国家，包括北美（美国、加拿大）、欧洲（英国、瑞典、法国等）、亚洲（日本、香港、印度等）。 优点: 流媒体解锁能力强、价格合理。 缺点: 服务器数量少、速度波动。 链接: PrivateVPN 17. Hotspot Shield 简介: 以高速连接著称，适合流媒体和游戏。 服务器数量: 1800+ 服务器 分布情况: 80+国家，包括北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（日本、印度、新加坡等）。 优点: 速度快、适合流媒体。 缺点: 免费计划广告多，隐私政策争议。 链接: Hotspot Shield 18. FastestVPN 简介: 价格低廉，适合基本隐私和流媒体需求。 服务器数量: 600+ 服务器 分布情况: 40+国家，包括北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（香港、日本、印度等）。 优点: 价格极低、基本功能齐全。 缺点: 服务器数量少、支持服务有限。 链接: FastestVPN 19. HideMyAss (HMA) 简介: 提供广泛的服务器网络，适合流媒体和地理解锁。 服务器数量: 1100+ 服务器 分布情况: 190+国家（含虚拟服务器），覆盖北美、欧洲、亚洲、非洲、南美、澳洲。 推荐指数: 7.6/10 优点: 国家覆盖最广、易用性高。 缺点: 曾有日志争议，隐私保护较弱。 链接: HideMyAss 20. ZenMate 简介: 简单易用，适合流媒体和轻度用户。 服务器数量: 4000+ 服务器 分布情况: 80+国家，包括北美（美国、加拿大）、欧洲（英国、德国、法国等）、亚洲（日本、香港、印度等）。 优点: 价格低、流媒体解锁效果好。 缺点: 隐私保护一般、速度不稳定。 链接: ZenMate ","date":"2025-05-06T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E5%85%A8%E7%90%83%E7%9F%A5%E5%90%8D%E9%9D%A0%E8%B0%B1%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84vpn%E5%8E%82%E5%AE%B6%E6%8E%A8%E8%8D%90/cover_hu_5493913472bc3c44.jpg","permalink":"https://dxjxpr.github.io/p/%E5%85%A8%E7%90%83%E7%9F%A5%E5%90%8D%E9%9D%A0%E8%B0%B1%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84vpn%E5%8E%82%E5%AE%B6%E6%8E%A8%E8%8D%90/","title":"全球知名、靠谱且实用的VPN厂家推荐"},{"content":"1. Vultr 简介: Vultr成立于2014年，是一家美国VPS提供商，以灵活的按小时计费和高性能云服务器著称，支持多种操作系统和自定义ISO。 机房数量: 32个数据中心 机房分布: 全球包括北美（美国洛杉矶、纽约、芝加哥等）、欧洲（伦敦、巴黎、阿姆斯特丹等）、亚洲（东京、新加坡、首尔等）、澳洲（悉尼、墨尔本）和南美（圣保罗）。 优点: 按小时计费，随时销毁重建，灵活性高。 支持支付宝，适合全球用户。 提供CN2 GIA线路，亚洲地区（如日本）延迟低。 硬件配置强大（Intel SSD、E3/E5 CPU）。 缺点: 晚高峰日本机房（NTT线路）延迟可能较高。 低价套餐资源竞争激烈，性能可能波动。 链接: Vultr 2. DigitalOcean 简介: 成立于2012年，总部位于美国纽约，以开发者友好和高性能云服务器闻名，提供强大的API和文档支持。 机房数量: 15个数据中心 机房分布: 北美（纽约、旧金山、多伦多）、欧洲（伦敦、阿姆斯特丹、法兰克福）、亚洲（新加坡、班加罗尔）和澳洲（悉尼）。 优点: 文档支持丰富，适合开发者和技术用户。 API功能强大，集成性好。 性能稳定，适合中小型网站和开发环境。 缺点: 亚洲机房数量较少，国内访问速度一般。 不支持支付宝，需双币信用卡或PayPal。 链接: DigitalOcean 3. Linode (现为Akamai) 简介: 成立于2003年，总部在美国新泽西，是VPS行业的常青树，以高性能硬件和优质技术支持著称。 机房数量: 11个数据中心 机房分布: 北美（纽瓦克、亚特兰大、达拉斯等）、欧洲（伦敦、法兰克福）、亚洲（东京、新加坡、孟买）和澳洲（悉尼）。 优点: 硬件配置顶尖（NVMe SSD、最新CPU），稳定性极佳。 技术支持响应快，适合个人站长和企业。 提供多种免费/付费附加服务（如备份、监控）。 缺点: 日本机房晚高峰延迟较高（NTT线路）。 需双币信用卡验证，支付门槛较高。 链接: Linode 4. AWS (Amazon Web Services) 简介: 全球最大的云服务提供商，提供EC2等VPS服务，适合企业级应用和复杂架构。 机房数量: 30+个区域（每个区域包含多个可用区） 机房分布: 全球覆盖北美、欧洲、亚洲（东京、新加坡、香港等）、南美、非洲、澳洲等。 优点: 机房分布最广，全球覆盖能力强。 提供丰富的云服务生态（数据库、AI、存储等）。 企业级高可用性和安全性。 缺点: 定价复杂，新手上手难度高。 成本较高，不适合预算有限的个人用户。 链接: AWS 5. Google Cloud Platform (GCP) 简介: 谷歌的云服务品牌，提供高性能VPS（Compute Engine），以AI和大数据处理能力著称。 机房数量: 35+个区域 机房分布: 北美（俄勒冈、爱荷华等）、欧洲（伦敦、苏黎世）、亚洲（东京、新加坡、台湾等）、南美、澳洲。 优点: 提供免费试用额度（300美元），适合测试。 网络质量优秀，适合高性能计算。 集成AI和机器学习工具。 缺点: 价格较高，计费复杂。 社区支持不如AWS丰富。 链接: Google Cloud 6. Microsoft Azure 简介: 微软的云服务平台，提供VPS（虚拟机）及企业级云解决方案，适合Windows生态用户。 机房数量: 60+个区域 机房分布: 全球覆盖北美、欧洲、亚洲（香港、新加坡、东京等）、南美、非洲、澳洲。 优点: 与Windows生态无缝集成，适合企业用户。 机房数量多，全球覆盖广。 提供免费试用（200美元额度）。 缺点: 价格偏高，个人用户成本压力大。 界面复杂，学习曲线陡峭。 链接: Microsoft Azure 7. Contabo 简介: 德国VPS提供商，以低价大内存和高性价比著称，适合预算有限的用户。 机房数量: 9个数据中心 机房分布: 欧洲（德国、英国）、北美（美国纽约、圣路易斯）、亚洲（新加坡、日本）、澳洲（悉尼）。 优点: 价格极低，提供大内存和存储（如4核8GB仅5欧元/月）。 适合高内存需求的场景（如数据库、建站）。 支持Windows和Linux。 缺点: 技术支持响应较慢。 亚洲机房延迟较高，国内访问速度一般。 链接: Contabo 8. OVHcloud 简介: 法国云服务商，提供VPS、云服务器和专用服务器，以高性价比和自有数据中心著称。 机房数量: 30+个数据中心 机房分布: 欧洲（法国、德国、波兰等）、北美（加拿大、美国）、亚洲（新加坡、印度）、澳洲。 优点: 自有数据中心，稳定性高。 提供DDoS防护，适合高风险应用。 价格竞争力强。 缺点: 亚洲机房数量少，国内访问延迟较高。 技术支持质量参差不齐。 链接: OVHcloud 9. Hetzner 简介: 德国老牌主机商，提供高性能VPS和专用服务器，以低价和高配置著称。 机房数量: 5个数据中心 机房分布: 欧洲（德国、芬兰）、北美（美国弗吉尼亚）。 优点: 性价比极高（如4核8GB仅6欧元/月）。 硬件性能强大（NVMe SSD、AMD EPYC CPU）。 网络稳定，欧洲用户体验佳。 缺点: 亚洲无机房，国内访问延迟高。 技术支持主要为德语/英语。 链接: Hetzner 10. Hostinger 简介: 立陶宛主机商，以虚拟主机起家，现提供高性价比VPS，适合中小型网站。\n机房数量: 8个数据中心\n机房分布: 北美（美国）、欧洲（英国、荷兰、立陶宛）、亚洲（新加坡、印度）、南美（巴西）。\n优点:\n价格低廉，适合初学者。 提供简单管理面板，易用性高。 支持多种CMS一键安装。 缺点:\n性能中等，适合低流量网站。 亚洲机房延迟较高。 链接: Hostinger\n11. Bluehost 简介: 美国知名主机商，以虚拟主机闻名，近年提供VPS服务，适合WordPress建站。\n机房数量: 4个数据中心\n机房分布: 北美（美国）、欧洲（英国）、亚洲（印度）。\n优点:\n适合WordPress用户，提供一键安装。\n客户支持响应快，适合新手。\n提供免费域名（首年）。\n缺点:\n价格偏高，性价比一般。 亚洲机房少，国内访问速度慢。 链接: Bluehost\n12. Scaleway 简介: 法国云服务商，提供低价VPS和云服务器，主打欧洲市场，适合预算用户。 机房数量: 4个数据中心 机房分布: 欧洲（法国、荷兰、波兰）。 优点: 价格极低（如1核1GB年付约40元人民币）。 支持IPv6，适合测试和轻量应用。 提供灵活的实例类型。 缺点: 亚洲无机房，国内访问延迟高。 性能一般，适合低负载场景。 链接: Scaleway 13. HostWinds 简介: 美国VPS提供商，提供KVM和OpenVZ虚拟化，适合个人和小型企业。 机房数量: 3个数据中心 机房分布: 北美（美国西雅图、达拉斯）、欧洲（阿姆斯特丹）。 优点: 提供Windows和Linux VPS，灵活性高。 客户支持24/7，响应快。 价格适中，适合中小项目。 缺点: 机房数量少，亚洲用户体验差。 性能稳定性中等。 链接: HostWinds 14. DMIT 简介: 美国VPS提供商，专注于CN2 GIA线路，适合国内用户，定位高端市场。 机房数量: 5个数据中心 机房分布: 北美（美国洛杉矶、圣何塞）、亚洲（香港、日本）。 优点: 提供CN2 GIA线路，国内访问速度快。 网络稳定性高，适合跨境电商。 支持KVM虚拟化，性能可靠。 缺点: 价格较高，性价比一般。 机房选择较少。 链接: DMIT 15. ZoroCloud 简介: 成立于2023年，香港新兴VPS提供商，主打CN2 GIA和联通9929线路，适合国内用户。 机房数量: 3个数据中心 机房分布: 亚洲（香港、美国、日本）。 优点: 提供CN2 GIA和9929线路，国内访问速度优异。 支持支付宝，购买方便。 适合建站和跨境电商。 缺点: 新商家，长期稳定性待观察。 机房数量少，覆盖范围有限。 链接: ZoroCloud 16. LightNode 简介: 新加坡VPS提供商，提供高性价比云服务器，适合亚洲用户。 机房数量: 20+个数据中心 机房分布: 亚洲（新加坡、香港、东京、台北等）、北美（美国）、欧洲（德国）、中东（沙特）、南美（巴西）。 优点: 亚洲机房丰富，国内访问延迟低。 价格实惠，按小时计费。 支持KVM虚拟化，性能稳定。 缺点: 品牌知名度较低，社区资源少。 技术支持响应速度中等。 链接: LightNode 17. VPSServer 简介: 美国VPS提供商，专注于高性能云服务器，支持Windows和Linux。 机房数量: 16个数据中心 机房分布: 北美（美国芝加哥、迈阿密等）、欧洲（伦敦、阿姆斯特丹）、亚洲（新加坡、东京）、澳洲（悉尼）。 优点: 提供多种操作系统选择，灵活性高。 网络稳定，适合全球用户。 支持按小时计费。 缺点: 价格偏高，性价比一般。 亚洲机房延迟对国内用户不够理想。 推荐指数: 7.8/10 链接: VPSServer 18. Megalayer 简介: 香港主机商，提供VdetailPS和独立服务器，主打CN2和直连线路，适合国内用户。 机房数量: 4个数据中心 机房分布: 亚洲（香港、美国圣何塞）、北美（美国）。 优点: 提供CN2和直连线路，国内访问速度快。 价格促销力度大（如独立服务器低至99元/月）。 支持高防和带宽升级。 缺点: 机房数量少，覆盖范围有限。 新用户可能需适应管理界面。 链接: Megalayer 19. HostGator 简介: 美国老牌主机商，以虚拟主机起家，提供VPS服务，适合中小型网站。 机房数量: 3个数据中心 机房分布: 北美（美国休斯顿、犹他州）。 优点: 提供cPanel管理面板，易用性高。 客户支持24/7，适合新手。 提供免费域名（首年）。 缺点: 亚洲无机房，国内访问延迟高。 价格偏高，性价比一般。 链接: HostGator 20. 搬瓦工 (BandwagonHost) 简介: 2012年成立，隶属加拿大IT7 Networks，高性价比KVM VPS，自研KiwiVM面板，支持CN2 GIA优化，适合中国用户建站、代理。\n机房数量: 11个\n机房分布:\n北美：美国（洛杉矶、弗里蒙特、圣何塞、纽约、新泽西、亚利桑那、佛罗里达）、加拿大（温哥华）\n欧洲：荷兰（阿姆斯特丹）\n亚洲：中国（香港）、日本（东京、大阪）\n中东：阿联酋（迪拜）\n优点:\n高性价比，入门套餐价格低\nCN2 GIA线路对中国大陆优化好，延迟低\n支持支付宝，支付便捷\n自研面板，管理简单\n缺点:\n低价套餐资源少，适合轻量任务\n非CN2 GIA机房延迟高\n热门套餐常断货\n技术支持响应一般，官网需翻墙\n链接: BandwagonHost\n21. Lisahost 简介: 新兴主机商，专注于双ISP/住宅IP/原生IP的VPS，适合跨境电商和特殊需求。 机房数量: 6个数据中心 机房分布: 亚洲（香港、台湾、日本、新加坡）、北美（美国）、欧洲（英国）。 优点: 提供双ISP和原生IP，适合电商和隐私需求。 亚洲机房延迟低，国内访问友好。 价格适中，促销活动多。 缺点: 新商家，长期稳定性待验证。 技术支持资源有限。 链接: Lisahost ","date":"2025-05-05T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E5%85%A8%E7%90%83%E7%9F%A5%E5%90%8D%E9%9D%A0%E8%B0%B1%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84vps%E5%8E%82%E5%AE%B6%E6%8E%A8%E8%8D%90/cover_hu_6bfb2eb6da139df7.jpg","permalink":"https://dxjxpr.github.io/p/%E5%85%A8%E7%90%83%E7%9F%A5%E5%90%8D%E9%9D%A0%E8%B0%B1%E4%B8%94%E5%AE%9E%E7%94%A8%E7%9A%84vps%E5%8E%82%E5%AE%B6%E6%8E%A8%E8%8D%90/","title":"全球知名、靠谱且实用的VPS厂家推荐"},{"content":"一、新标签页 当我们安装上谷歌浏览器的时候，打开一个新的标签页是只有一个谷歌搜索栏，背景颜色是白色（下图是安装了星空主题），即使是安装了星空主题，打开新标签页看着也是比较单一，如果想要新标签页好看，就需要通过扩展插件的方式，来DIY你的新标签页了，这里推荐两个新标签页的插件：WeTab、Infinity\n安装方式，打开谷歌商店，直接搜索要安装的插件名称，然后点击安装即可\n1、WeTab新标签页 刚安装上的效果如下\n个人比较喜欢简洁，就修改成了以下风格，右上方有个树叶按钮可以进行切换，至于背景颜色，点击左下角的小齿轮设置按钮来进行设置即可\n2、Infinity New Tab(Pro) 二、黑暗阅读插件 Dark Reader\n这个插件可以切换页面的背景颜色，变成暗黑，一般搞计算机的朋友比较偏爱暗黑模式\n比如使用Bing搜索世界地图，背景颜色是白色\n开启暗黑模式\n或者使用Ctrl+shift+D快捷键来回切换，以下就是切换成暗黑模式的样子\n三、购物党自动比价 在购物网站上可以看到当前商品近半年的价格走势，比如看个包子的价格\n","date":"2025-04-29T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E5%A5%BD%E7%94%A8%E7%9A%84%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/cover_hu_e44d86cae839b1c0.jpg","permalink":"https://dxjxpr.github.io/p/%E5%A5%BD%E7%94%A8%E7%9A%84%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","title":"好用的谷歌插件推荐"},{"content":"1、 电脑硬件时间，也就是电脑主板的BIOS上显示的时间 2、介绍三种时间标准\n1 2 3 4 5 UTC，即Coordinated Universal Time，协调世界时 GMT，即Greenwich Mean Time，格林尼治标准时间 RTC，即Real-time clock，实时时钟 3、Windows与Linux看待BIOS里时间的方式不一样\nLinux时钟分为系统时钟（System Clock）和硬件时钟（RTC）。Linux把硬件时间当作UTC，系统时间是UTC时间经过换算过来的（就是东几区：加时间，西几区：减时间）。比如北京时间，就是GMT+8,在windows里是凌晨00:00，那么在Linux中就是08:00，多八个小时，这是与所在的地理位置有关，此处就请科普下地理知识，经度纬度，以及地球公转自转，太阳照射时间等知识信息 Windows系统就直接读取了系统硬件时间（RTC），当作本地时间（Local time），因此windows系统时间和BIOS中显示的时间（RTC）是一样的\n4、解决方法，在ubuntu，打开终端，执行以下命令\n1 2 3 4 5 sudo apt install ntpdate # 使用ntp同步时间 sudo ntpdate time.windows.com # 同步微软windows时间 sudo hwclock --localtime --systohc # 将时间跟新到硬件上 # 如果显示没有hwclock命令，就先安装该命令 # sudo apt install util-linux-extra 如果同步之后，windows的时间依旧没有更新，一般是你电脑的时间同步按钮打开了，关闭这个同步功能，再打开这个功能，调整一下，然后就可以了。\n另外一个方式，在ubuntu里执行命令\n1 2 3 4 timedatectl set-local-rtc 1 --adjust-system-clock # --adjust-system-clock 参数解释 # 当使用set-local-rtc命令时，若使用了此选项，则表示根据RTC时间来更新系统时钟,而不是用UTC来更新（UTC需要+8）。 # 若未使用此选项，则表示根据系统时钟来更新RTC时间。 然后重启电脑\n","date":"2025-02-21T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E8%A7%A3%E5%86%B3ubuntu%E5%92%8Cwindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/cover_hu_b129945d8262ce81.jpg","permalink":"https://dxjxpr.github.io/p/%E8%A7%A3%E5%86%B3ubuntu%E5%92%8Cwindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/","title":"解决Ubuntu和Windows双系统时间不同步问题"},{"content":"[TOC]\n本文仅仅供学习参考使用，无任何盈利性质，单纯技术分享，不承担任何法律责任，所有使用该技术的人员引发的后果自行承担相应后果 本文仅分享科学上网技术，用来学习计算机知识，查询资料，比如医学、计算机、绘画等各领域学习使用 请勿私自搭建进行违法犯罪活动 一、准备工作 1、vps厂商选择 搭建一个科学上网服务器，那么必然是需要一个云服务器作为物理基础，才能进行搭建，这里就应用Github上mmhunter3515大佬整理的VPS厂商，整理的很详细，在这里就列举几个\nVultr：https://www.vultr.com/ Lightnode：ttps://www.lightnode.com/ Google：https://cloud.google.com/ AWS：https://aws.amazon.com/ 2、注册账号与充值 本文选择vultr厂商，这个厂商的数据中心较多，于是使用的人也就很多，很多人选择这个厂商的服务器搭建网站之类，于是出现一个就封锁一个ip，就造成了vultr厂商的很多ip被封了，所以，在创建实例的时候，就会出现很有可能无法连接，因为被封了。本文只是为了演示技术，就还是选择vultr厂商（其实是没有钱去其他网站充值了，也就这个网站还有几刀可以嚯嚯）\n下面是vultr的主界面\n首先需要一个账号，点击右上角的Sign up自行注册一个账户，推荐使用Gmail邮箱\n注：关于注册账号和充值部分，厂家可能会不定期给一些优惠券或者是返还之类，这个就需要大家执行去翻阅查找资料了\n注册完成后，需要充值，最低需要$10，支持支付宝充值\n二、开始创建ECS实例 1、部署服务器 选择Products的Compute界面，可以看到Deploy Server\n创建实例\n关闭自动备份后，价格就降低几美元（一方面省钱，另外一方面其实也没有那个必要）\n然后点击Configure Software进入到镜像选择的界面，系统镜像选择，一般选择CentOS，版本的话，选择最新版本就好\n点击开始部署后，稍等两秒就会自动跳转到实例列表界面，创建实力耗时约1min\n2、测试ip连通性 当实例创建完成后，会自动分配一个ip，点击实例名称，进入详细界面，就可以看到当前实例的root账户和密码\n复制ip地址，如果是macos电脑或者是linux打开终端，如果是windows电脑，就打开cmd，使用ping命令测试一下能否ping的通，如下图，就表示ping的通，可以ssh连接\n如果你创建的实例，分配的ip地址，无法ping通，那么就销毁当前实例，再重新创建一个实例，更换国家或者地区，多尝试几次，总归是可以创建成功的。\n3、ssh登陆实例 如果你的电脑是macos或者是linux，那么直接使用终端就可以直接进行ssh登陆了。如果你的电脑是windows，那么也能够使用cmd进行ssh登陆，或者是安装像xshell、PuTTY、SecureCRT、MobaXterm这样的ssh工具（请自行下载和安装）\n4、安装必要软件和镜像库 执行以下命令，安装相关软件，以及epel库\n1 2 3 4 5 6 sudo yum install -y epel-release sudo yum clean all sudo yum makecache sudo yum update -y sudo yum upgrade sudo yum install -y wget vim git curl zlib* gcc gcc-c++ automake autoconf libtool make 三、一键部署脚本 1、下载并执行管理脚本 CentOS/Debian/Ubuntu ShadowsocksR一键部署管理脚本，执行命令\n1 2 3 4 5 6 # 下载一键安装脚本 wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh # 增加可执行权限 chmod +x shadowsocksR.sh # 开始执行 ./shadowsocksR.sh 2\u0026gt;\u0026amp;1 | tee shadowsocksR.log 设置密码，直接回车，默认密码即可\n设置端口，直接回车，默认端口即可\n加密方式，直接回车，使用默认的加密协议即可\n设置协议，直接回车，默认协议即可\n设定混淆方式，default 为默认混淆，直接回车，默认即可\n安装成功，按任意键，自动启动\n然后会自动安装一些脚本\n最终，安装完成，会显示刚才所配置的信息，将下面的配置信息保存好，以便客户端使用。\n安装过后如果想要修改，运行如下相关命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 启动 /etc/init.d/shadowsocks start # 停止 /etc/init.d/shadowsocks stop # 重启 /etc/init.d/shadowsocks restart # 状态 /etc/init.d/shadowsocks status # 配置文件路径 /etc/shadowsocks.json # 修改文件用vi 或者 vim命令，使用方法百度 # 日志文件路径 /var/log/shadowsocks.log # 安装路径 /usr/local/shadowsocks/shadowsoks # 卸载 ./shadowsocksR.sh uninstall 2、查看状态并启动 执行命令/etc/init.d/shadowsocks status查看状态\n1 2 root@vultr:~# /etc/init.d/shadowsocks status ShadowsocksR is stopped 执行命令/etc/init.d/shadowsocks start启动服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 root@vultr:~# /etc/init.d/shadowsocks start Traceback (most recent call last): File \u0026#34;/usr/local/shadowsocks/server.py\u0026#34;, line 32, in \u0026lt;module\u0026gt; from shadowsocks import shell, daemon, eventloop, tcprelay, udprelay, \\ File \u0026#34;/usr/local/shadowsocks/../shadowsocks/shell.py\u0026#34;, line 26, in \u0026lt;module\u0026gt; from shadowsocks.common import to_bytes, to_str, IPNetwork, PortRange File \u0026#34;/usr/local/shadowsocks/../shadowsocks/common.py\u0026#34;, line 27, in \u0026lt;module\u0026gt; from shadowsocks import lru_cache File \u0026#34;/usr/local/shadowsocks/../shadowsocks/lru_cache.py\u0026#34;, line 44, in \u0026lt;module\u0026gt; class LRUCache(collections.MutableMapping): ^^^^^^^^^^^^^^^^^^^^^^^^^^ AttributeError: module \u0026#39;collections\u0026#39; has no attribute \u0026#39;MutableMapping\u0026#39; Starting ShadowsocksR failed 在启动时候出现报错，根据报错信息查看，是由于python的collections库没有MutableMapping属性，这是由于在python3中collections的模块有所变动，需要把\n1 collections.MutableMapping 变成\n1 collections.abc.MutableMapping 根据报错信息可以明确看到，是由于/usr/local/shadowsocks/lru_cache.py文件中，第44行报错，那么就修改这个位置，增加abc，修改后如下图，然后保存并退出\n再次执行命令/etc/init.d/shadowsocks start启动服务，此时启动成功，报错信息消失\n1 2 3 4 5 6 root@vultr:~# /etc/init.d/shadowsocks start IPv6 support 2025-02-17 08:31:52 INFO util.py:94 loading libcrypto from libcrypto.so.3 2025-02-17 08:31:52 INFO shell.py:74 ShadowsocksR SSRR 3.2.2 2018-05-22 started Starting ShadowsocksR success 再次执行命令/etc/init.d/shadowsocks status查看状态，状态正常\n1 2 root@vultr:~# /etc/init.d/shadowsocks status ShadowsocksR (pid 50662) is running... 3、关闭/放行防火墙 在服务启动之后，系统防火墙是启动的状态，并未放行其对应的端口号，需要关闭防火墙，或者是在防火墙中放行端口，这样客户端才能够访问，否则无法使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 查看防火墙状态 root@vultr:~# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; preset: enabled) Active: active (running) since Mon 2025-02-17 09:06:05 UTC; 16s ago Invocation: 80def4cc4c7442b0b4209d49a4a12d4b Docs: man:firewalld(1) Main PID: 50936 (firewalld) Tasks: 2 (limit: 10802) Memory: 25.4M (peak: 27M) CPU: 211ms CGroup: /system.slice/firewalld.service └─50936 /usr/bin/python3 -sP /usr/sbin/firewalld --nofork --nopid Feb 17 09:06:05 vultr.guest systemd[1]: Starting firewalld.service - firewalld - dynamic firewall daemon... Feb 17 09:06:05 vultr.guest systemd[1]: Started firewalld.service - firewalld - dynamic firewall daemon. 1 2 # 查看防火墙已放行的端口，这里是空的 root@vultr:~# firewall-cmd --list-ports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # 方法一 # 安装服务管理脚本时，创建的端口是16782，这里在防火墙中为该端口永久放行 root@vultr:~# firewall-cmd --zone=public --add-port=16782/tcp --permanent success # 防火墙配置完成后，重新加载 root@vultr:~# sudo firewall-cmd --reload success # 再次查看防火墙放行端口 root@vultr:~# sudo firewall-cmd --list-all public (default, active) target: default ingress-priority: 0 egress-priority: 0 icmp-block-inversion: no interfaces: enp1s0 sources: services: cockpit dhcpv6-client ssh ports: 16782/tcp # 已放行的端口 protocols: forward: yes masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 方法二 # 关闭防火墙 root@vultr:~# systemctl stop firewalld root@vultr:~# # 查看防火墙状态 root@vultr:~# systemctl status firewalld ○ firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; preset: enabled) Active: inactive (dead) since Mon 2025-02-17 09:14:30 UTC; 33s ago Duration: 8min 25.285s Invocation: 80def4cc4c7442b0b4209d49a4a12d4b Docs: man:firewalld(1) Process: 50936 ExecStart=/usr/sbin/firewalld --nofork --nopid $FIREWALLD_ARGS (code=exited, status=0/SUCCESS) Main PID: 50936 (code=exited, status=0/SUCCESS) Mem peak: 29.3M CPU: 390ms Feb 17 09:06:05 vultr.guest systemd[1]: Starting firewalld.service - firewalld - dynamic firewall daemon... Feb 17 09:06:05 vultr.guest systemd[1]: Started firewalld.service - firewalld - dynamic firewall daemon. Feb 17 09:14:30 vultr.guest systemd[1]: Stopping firewalld.service - firewalld - dynamic firewall daemon... Feb 17 09:14:30 vultr.guest systemd[1]: firewalld.service: Deactivated successfully. Feb 17 09:14:30 vultr.guest systemd[1]: Stopped firewalld.service - firewalld - dynamic firewall daemon. 4、下载客户端 Mac：https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases\nWin：https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases\niPhone：到商店里安装FirstWingy、potatso lite。（搞一个美国appleID）\n本人电脑是MacOS，就以Mac为例，下载ShadowsocksX-NG-R8.dmg，打开，然后双击绿色的ShadowsocksX-NG-R8\n双击完后，会提示当前软件不安全，此时需要打开电脑设置-Privacy \u0026amp; Scurity，在最下面会出现这个软件的信息，然后点击Open Anyway，输入电脑密码就可以打开\n打开完成后，电脑的右上角图标就会出现一个小飞机图标，这个就是shadowsocks\n然后点击小飞机\u0026ndash;Servers\u0026ndash;Server Preferences\n啟動成功後，這裡以訪問Google和Youtube為例，\n使用搜索一個世界上最受歡迎的網站\n訪問全球最大同性交友網站Github\n","date":"2025-02-17T19:00:00+08:00","image":"https://dxjxpr.github.io/p/%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%85%E4%BE%9B%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E4%BD%BF%E7%94%A8/cover_hu_d910f09f25891309.png","permalink":"https://dxjxpr.github.io/p/%E6%90%AD%E5%BB%BA%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%85%E4%BE%9B%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E4%BD%BF%E7%94%A8/","title":"搭建科学上网服务器（仅供学习参考使用）"},{"content":"使用iTerm2 + oh-my-zsh + Powerlevel10k打造macOs潮流又实用的Terminal保姆级教学\n[TOC]\n一、先展示最终效果图 顺便跑个彩色小火车给大家快乐下（命令：sl | lolcat）\n下面我们开始今天的安装教程\n二、安装iTem2终端 首先到到iTem2的官网https://iterm2.com/downloads.html下载安装包，下载下来的安装包是一个.zip的压缩文件，进行解压，解压后，双击进行安装，或者可以直接将该应用程序放入到Applications目录下，然后就可以在Lauchpad里看到iTem的图标，点击即可启动\niTem2的功能丰富，更加全面的可以查看官方文档：https://iterm2.com/documentation.html\n至于配色、字体大小、窗口大小等配置信息，可以在设置中，自行进行配置\n三、安装oh-my-zsh配置框架 oh-my-zsh是一个管理zsh配置的开源框架，该框架插件生态丰富，比如代码高亮、代码提示等，还有很多主体（此次的主题就是Powerlevel10k主题）\n首先需要下载安装zsh的shell，执行以下命令，并将zsh设置为默认的shell\n1 2 brew update brew install zsh 查看当前shell\n1 echo $SHELL 如果当前shell不是zsh，将shell切换成zsh\n1 chsh -s /bin/zsh 安装oh-my-zsh，官网：https://ohmyz.sh/#install\n执行以下命令：\n1 2 3 4 5 6 sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; # 或者 sh -c \u0026#34;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\u0026#34; # 两个安装命令选择一个即可，个人一般使用第一个，这个无所谓 安装完成后，可以看到如下的oh-my-zsh的彩色图标，同时可以看到光标前面的提示符变成了向右的箭头，这里默认的主题是robbyrussell，主题的配置信息都是~/.zshrc配置文件中\n四、安装插件 安装oh-my-zsh后，建议安装定制的插件，这里介绍两个zsh-autosuggestions和zsh-syntax-highlighting\nzsh-autosuggestions 该插件在用户键入时，是根据命令行历史和完整命令名推荐余下的输入 zsh-syntax-highlighting 此插件对zsh提示符后的输入自动匹配语法高亮，可以让用户在实际命令运行前审核输入行，以便及时发现和改正语法错误。 安装方式，是将插件从github上克隆到~/.oh-my-zsh/custom/plugins目录下，然后编辑~/.zshrc文件，找到plugins=(git)那一行，将所安装的插件，放入到插件列表中，同时为了保证语法高亮的效果zsh-syntax-highlighting插件必须置于插件列表的最后一项，如下\n1 2 3 4 5 plugins=( git zsh-autosuggestions zsh-syntax-highlighting ) 然后退出item2终端，重新启动才能生效\n五、配置Powerlevel10k主题 powerlevel10k是为zsh定制而做的主题，有以下主要特征\n界面美观 即时反馈 集成git 及其他特点 在oh-my-zsh环境下的安装很简单，直接从github源克隆powerlevel10k仓库到~/.oh-my-zsh/custom/themes目录下\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 中国大陆地区也可以使用gitee上的官方镜像加速下载\n1 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 编辑.zshrc文件，将主题更改为powerlevel10k，找到ZSH_THEME=\u0026quot;robbyrussell\u0026quot;那一行，然后将robbyrussell更换为powerlevel10k/powerlevel10k，如下\n1 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 安装完成后，执行命令source ~/.zshrc或者是退出iTem2重启一下，然后就会自动触发Powerlevel10k配置向导（Configuration Wizard），然后跟随提示，一步步进行配置，以下是根据个人喜好进行的配置，仅供参考学习，大体流程如下\n在配置powerlevel10k之前，可能会提示你：询问是否安装推荐的字体（Meslo Nerd Font），然后选择安装，安装完成后需要重启item2，然后重启，重新进入powerlevel10k的配置流程\n1、问：这看起来像钻石（旋转的正方形）吗？\n答：y\n2、问：这看起来像一把锁吗？\n答：y\n3、问：这看起来像一个向上的箭头吗？\n答：y\n4、问：向下的箭头指向什么数字？\n答：1\n5、问：所有这些图标都适合十字吗？\n答：y\n6、选择一个提示风格，个人比较喜欢（3）Rainbow，所以这里就选择3，你可根据你的喜好选择，这里就输入：3\n然后回车\n7、字符集的选择，(1) Unicode.这里就输入1，然后回车\n8、当前时间显示的格式，或者不显示，个人喜欢24小时制，你可以根据自身喜好选择，这里输入2，然后回车\n9、提示分割符，个人喜欢箭头型，就选择(1) Angled，你可根据自身喜好选择，这里就输入1，然后回车\n10、提示头的选择，个人喜欢箭头，你可以根据自身喜好选择，这里就输入3，然后回车\n11、提示尾部的选择，个人喜欢波浪，你可以根据自身喜好选择，这里就输入2，然后回车\n12、命令行的提示高度，是换行，还是在当前行，个人选择（1）One line，你可根据自身喜好选择，这里就输入1，然后回车\n13、命令行是否紧凑，个人喜欢紧凑，选择（1）Compact 你可以根据自身喜好选择，这里就输入1，然后回车\n14、图标样式的选择，个人喜欢多一点的，就选择2，你可以根据自身喜好选择，这里就输入2，然后回车\n15、提示流程的选择，个人感觉图标多点图标比架炫酷，就选择2，你可根据自身喜好选择，这里就输入2，然后回车\n16、是否启用瞬态提示，选择n，否则就没有图标好看了，当然，你也可以选择1，根据自身喜好选择，这里就输入n，然后回车\n17、即时提示模式，选择1，然后回车\n18、是否将刚才的配置信息写入配置文件，选择y，然后回车即可\n最后，大功告成，看着就很炫酷，当然还有更多更炫酷的配置，比如设置字体颜色，也可以找寻更多的插件，这里就抛砖引玉。\n如果对觉得配置的主题不是很好看，想重新配置，在终端中执行命令\n1 p10k configure 执行完成后就可以重新配置powerlevel10k主题了\n","date":"2025-01-19T21:30:00+08:00","image":"https://dxjxpr.github.io/p/%E6%89%93%E9%80%A0macos%E8%B6%85%E7%BA%A7%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AFitem2-oh-my-zsh-powerlevel10k/oh-my-zsh_hu_9391a5820ff06814.png","permalink":"https://dxjxpr.github.io/p/%E6%89%93%E9%80%A0macos%E8%B6%85%E7%BA%A7%E7%82%AB%E9%85%B7%E7%BB%88%E7%AB%AFitem2-oh-my-zsh-powerlevel10k/","title":"打造macOs超级炫酷终端item2+oh-my-zsh+Powerlevel10k"},{"content":"下载红帽RHEL系统ISO镜像文件 下载地址：https://access.redhat.com/downloads/content/rhel\n下载DVD格式的，这个包是最全的\n下载下来后的RHEL9.5 ISO镜像文件\n1 2 3 [root@localhost html]# ls -lh total 11G -rwxr-xr-x 1 ly ly 11G Jan 14 17:16 rhel-9.5-x86_64-dvd.iso 挂载ISO 将下载好的iso文件放入到某个目录中，我这里是放在了/root/OS/\n1 2 3 4 [root@localhost html]# pwd /var/html [root@localhost html]# ls rhel-9.5-x86_64-dvd.iso 然后创建一个/dvd的目录用来进行挂载\n编辑文件vim /etc/fstab，在最后一行新添加以下信息\n1 /root/OS/rhel-9.5-x86_64-dvd.iso /var/www/html/dvd iso9660 defaults,loop,ro 0 0 如果是临时挂载的话，执行命令：mount -o loop /root/OS/rhel-9.5-x86_64-dvd.iso /var/www/html/dvd\n安装并启动httpd服务 执行以下命令，安装httpd服务\n1 2 3 4 # 安装 sudo yum install httpd -y # 启动 sudo systemctl start httpd 为了测试httpd服务是否正常，在创建/var/www/html/index.html文件，并随便写点内容，比如：Hello World!，然后重启httpd服务\n1 sudo systemctl restart httpd 然后打开浏览器，输入当前主机的ip地址，即可在页面上看到Hello World!\n创建yum源 编辑文件vim /etc/yum.repos.d/dvd.repo，写入以下内容\n1 2 3 4 5 [dvd] name=dvd\t# 这只是一个名字而已 baseurl=file:///dvd/BaseOS # dvd就是要挂载的目录 enabled=1\t# 1表示启动YUM源，0为禁用 gpgcheck=0\t#1为检查GPG-KEY，0为不检查 其他站点的/etc/yum.repos.d/dvd.repo文件写以下内容\n1 2 3 4 5 6 [dvd] name=dvd # 注：这里使用http，https无法访问 baseurl=http://刚创建yum源的主机IP地址/dvd/BaseOS enabled=1 gpgcheck=0 然后可以在浏览器中访问这个baseurl测试能否连接成功，如果没有请重启httpd服务重试\n清除YUM缓存并测试安装\n执行以下命令\n1 2 3 4 5 6 7 8 9 # 清除缓存 yum clean all yum makecache # 列出当前配置的yum仓库所有可用的软件包及其版本信息 yum repolist # 下载软件 yum install 你要安装的软件名 -y ","date":"2025-01-14T21:30:00+08:00","image":"https://dxjxpr.github.io/p/%E7%BA%A2%E5%B8%BDrhel9%E6%90%AD%E5%BB%BA%E5%B1%80%E5%9F%9F%E7%BD%91%E9%95%9C%E5%83%8F%E6%BA%90%E4%B8%8E%E6%B0%B8%E4%B9%85%E6%8C%82%E8%BD%BDiso%E6%96%87%E4%BB%B6/rhel9_hu_c344d2ab4bc714c0.png","permalink":"https://dxjxpr.github.io/p/%E7%BA%A2%E5%B8%BDrhel9%E6%90%AD%E5%BB%BA%E5%B1%80%E5%9F%9F%E7%BD%91%E9%95%9C%E5%83%8F%E6%BA%90%E4%B8%8E%E6%B0%B8%E4%B9%85%E6%8C%82%E8%BD%BDiso%E6%96%87%E4%BB%B6/","title":"红帽RHEL9搭建局域网镜像源与永久挂载ISO文件"},{"content":"背景说明 操作系统版本，红帽RHEL9版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [root@localhost ~]# cat /etc/os-release NAME=\u0026#34;Red Hat Enterprise Linux\u0026#34; VERSION=\u0026#34;9.5 (Plow)\u0026#34; ID=\u0026#34;rhel\u0026#34; ID_LIKE=\u0026#34;fedora\u0026#34; VERSION_ID=\u0026#34;9.5\u0026#34; PLATFORM_ID=\u0026#34;platform:el9\u0026#34; PRETTY_NAME=\u0026#34;Red Hat Enterprise Linux 9.5 (Plow)\u0026#34; ANSI_COLOR=\u0026#34;0;31\u0026#34; LOGO=\u0026#34;fedora-logo-icon\u0026#34; CPE_NAME=\u0026#34;cpe:/o:redhat:enterprise_linux:9::baseos\u0026#34; HOME_URL=\u0026#34;https://www.redhat.com/\u0026#34; DOCUMENTATION_URL=\u0026#34;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9\u0026#34; BUG_REPORT_URL=\u0026#34;https://issues.redhat.com/\u0026#34; REDHAT_BUGZILLA_PRODUCT=\u0026#34;Red Hat Enterprise Linux 9\u0026#34; REDHAT_BUGZILLA_PRODUCT_VERSION=9.5 REDHAT_SUPPORT_PRODUCT=\u0026#34;Red Hat Enterprise Linux\u0026#34; REDHAT_SUPPORT_PRODUCT_VERSION=\u0026#34;9.5\u0026#34; 1、安装EPEL存储库 首先执行命令sudo yum install epel-release -y 进行安装，-y参数会自动安装，安装过程中无需手动敲y\n可能会出现找不到匹配的软件包\n1 2 3 4 5 [root@localhost ~]# sudo yum install epel-release -y Updating Subscription Management repositories. Last metadata expiration check: 2:16:32 ago on Mon 13 Jan 2025 07:12:38 PM CST. No match for argument: epel-release Error: Unable to find a match: epel-release 解决方法：\n启用EPEL存储库，需要安装yum-utils软件包，然后使用yum-config-manager命令启用EPEL存储库，执行以下命令：\n1 2 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --enable epel 然后再尝试安装epel-release软件包，执行以下命令\n1 2 3 4 sudo yum install epel-release # 注：如果该条命令依旧显示无法找到匹配的软件包，可以尝试使用以下命令（个人是使用这个命令执行成功的） # sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm 安装epel-release后，更新系统包缓存，执行以下命令\n1 2 3 sudo yum clean all sudo yum makecache sudo yum update 2、设置docker的yum源 执行以下命令，在yum中添加docker源\n1 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 3、安装docker 在正式安装docker之前，如果当前主机中安装的有旧版docker或者不是docker-ce的版本，先进行卸载，执行命令\n1 2 3 4 5 6 7 8 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 开始安装docker-ce、docker-ce-cli、containerd.io，执行以下命令\n1 sudo yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 然后等待完成安装即可\n4、docker配置文件 使用vi/vim编辑vim /etc/systemd/system/docker.service文件，将以下内容写入该文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com BindsTo=containerd.service After=network-online.target firewalld.service containerd.service Wants=network-online.target Requires=docker.socket [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 Restart=always # Note that StartLimit* options were moved from \u0026#34;Service\u0026#34; to \u0026#34;Unit\u0026#34; in systemd 229. # Both the old, and new location are accepted by systemd 229 and up, so using the old location # to make them work for either version of systemd. StartLimitBurst=3 # Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230. # Both the old, and new name are accepted by systemd 230 and up, so using the old name to make # this option work for either version of systemd. StartLimitInterval=60s # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity # Comment TasksMax if your systemd version does not support it. # Only systemd 226 and above support this option. TasksMax=infinity # set delegate yes so that systemd does not reset the cgroups of docker containers Delegate=yes # kill only the docker process, not all processes in the cgroup KillMode=process [Install] WantedBy=multi-user.target 使用vi/vim编辑vim /etc/systemd/system/docker.socket文件，将以下内容写入该文件中\n1 2 3 4 5 6 7 8 9 10 11 12 [Unit] Description=Docker Socket for the API PartOf=docker.service [Socket] ListenStream=/run/docker.sock SocketMode=0660 SocketUser=root SocketGroup=root [Install] WantedBy=sockets.target 5、配置docker的daemon.json 首先登陆阿里云账号，阿里云地址：https://cn.aliyun.com/，找到并点击控制台，然后搜索：容器镜像服务。点击进入\n然后编辑文件vim /etc/docker/daemon.json，将以下内容写入你的daemon.json文件中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;dns\u0026#34;: [\u0026#34;8.8.8.8\u0026#34;, \u0026#34;8.8.4.4\u0026#34;], \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://你的阿里云镜像加速地址\u0026#34;, // 注：该行自行添加你自己阿里云的镜像加速地址 \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://omh8vcpy.mirror.aliyuncs.com\u0026#34;, \u0026#34;https://docker.m.daocloud.io/\u0026#34;, \u0026#34;https://huecker.io/\u0026#34;, \u0026#34;https://dockerhub.timeweb.cloud\u0026#34;, \u0026#34;https://noohub.ru/\u0026#34;, \u0026#34;https://dockerproxy.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34;, \u0026#34;https://docker.nju.edu.cn\u0026#34;, \u0026#34;https://xx4bwyg2.mirror.aliyuncs.com\u0026#34;, \u0026#34;http://f1361db2.m.daocloud.io\u0026#34;, \u0026#34;https://registry.docker-cn.com\u0026#34;, \u0026#34;http://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://docker.mirrors.ustc.edu.cn\u0026#34; ] } 然后重新加载守护进程，执行命令sudo systemctl daemon-reload\n6、启动docker 启动docker\n1 sudo systemctl start docker 至此docker安装完毕，并且启动成功\n7、docker其他相关命令 重启docker服务\n1 sudo systemctl restart docker 拉取docker镜像，既然是软件，那么怎么能少的了我们的HelloWorld呢，此处就以拉取hello-world镜像为例，执行命令docker pull 你要拉取的镜像名及版本包，注：若没有版本号，那么拉取的就是最新的（latest）版本\n1 docker pulll hello-world 查看docker已拉取下来的镜像有哪些\n1 docker images ","date":"2025-01-13T21:30:00+08:00","image":"https://dxjxpr.github.io/p/%E7%BA%A2%E5%B8%BDrhel9%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85docker%E5%8F%8A%E9%85%8D%E7%BD%AE/docker_hu_8a237727c8881955.png","permalink":"https://dxjxpr.github.io/p/%E7%BA%A2%E5%B8%BDrhel9%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85docker%E5%8F%8A%E9%85%8D%E7%BD%AE/","title":"红帽RHEL9环境安装docker及配置"},{"content":"环境说明 操作系统：CentOS Linux release 7.9.2009 (Core) 本次安装MySQL版本：8.0.26 连接工具：xshell、xftp（或者其他连接/上传工具） 从腾讯云买的服务器，按量计费，临时用下，经济实惠（如果哪天有空写写服务器购买吧） 开始 1、查看centos7中是否有MariaDB，MariaDB与MySQL关系请自行查阅\nrpm -qa | grep mariadb\n2、如果有MariaDB，需要将 步骤1 中查询到的mairadb全部卸载，否则MySQL安装会出现问题\nrpm -e \u0026ndash;nodeps 软件名\n3、查看本机是否已经安装过MySQL\nrpm -qa | grep -i mysql\n4、如果安装过MySQL，请确定是否有数据需要备份（如果有需要备份的数据请自行查阅相关操作进行备份，否则数据丢失概不负责）\n如果没有安装过MySQL，请跳转步骤6\n5、卸载MySQL\n将步骤3中查询到的mysql安装包全部卸载 rpm -e \u0026ndash;nodeps 软件名\n查找mysql文件，并将其删除 find / -name mysql whereis mysql\n将find命令和whereis命令查询到的mysql文件全部删除\nrm -rf 查询到的mysql路径\n删除mysql配置文件\nrm /etc/my.cnf\n确认是否全部删除mysql rpm -qa | grep -i mysql\n6、MySQL官网下载适用于centos7的mysql安装包 查询服务器是x86_64架构还是arm架构\nuname -m 或者是 arch # 我的服务器是x86_64的\n这里可以下载直接通过浏览器下载下来，然后通过ftp上传到所要安装的服务器中 或者是复制这个tar包的链接，然后通过wget命令下载，操作如下 wget 文件的网络地址\n比如我这里下载的地址是\nwget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar\n无论是通过xftp工具还是wget命令，将MySQL的tar包传到centos的某个目录下（比如home目录下），这里演示的是上传到root用户的home目录下 7、解压tar包 在解压之前，建议先创建一个空的目录，因为这个tar包解压后多个rpm包会直接放到当前目录。因为我的tar包是在root用户的home目录下，所以直接在这个目录下创建了一个mysql的目录。这个目录无所谓！\nmkdir mysql 解压该tar包\ntar -xvf mysql的tar包全名 -C 解压到指定目录 # 说明：-C参数，后面跟的是目录，意思是将压缩包解压缩后存放到指定的目录下。\n# 这里就指定到刚才创建的mysql目录下\n8、开始安装MySQL\nrpm安装命令 rpm -ivh xxx.rpm\n# 这里选择的是全部安装 # 安装顺序如下，否则会出现依赖问题 mysql-community-common-8.0.26-1.el7.x86_64.rpm mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm mysql-community-embedded-compat-8.0.26-1.el7.x86_64.rpm mysql-community-libs-8.0.26-1.el7.x86_64.rpm mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm mysql-community-devel-8.0.26-1.el7.x86_64.rpm mysql-community-client-8.0.26-1.el7.x86_64.rpm mysql-community-server-8.0.26-1.el7.x86_64.rpm mysql-community-test-8.0.26-1.el7.x86_64.rpm\n以上安装rpm时可能会出现centos的动态库缺失等情况，这里记录下几种错误情况 情况1： [root@VM-0-14-centos mysql]# rpm -ivh mysql-community-embedded-compat-8.0.26-1.el7.x86_64.rpm warning: mysql-community-embedded-compat-8.0.26-1.el7.x86_64.rpm: Header V3 DSA/SHA256 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies: libnuma.so.1()(64bit) is needed by mysql-community-embedded-compat-8.0.26-1.el7.x86_64 libnuma.so.1(libnuma_1.1)(64bit) is needed by mysql-community-embedded-compat-8.0.26-1.el7.x86_64 libnuma.so.1(libnuma_1.2)(64bit) is needed by mysql-community-embedded-compat-8.0.26-1.el7.x86_64\n解决方式：\nyum -y install numactl 情况2 [root@VM-0-14-centos mysql]# rpm -ivh mysql-community-devel-8.0.26-1.el7.x86_64.rpm warning: mysql-community-devel-8.0.26-1.el7.x86_64.rpm: Header V3 DSA/SHA256 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies: pkgconfig(openssl) is needed by mysql-community-devel-8.0.26-1.el7.x86_64\n解决方式\nyum install openssl-devel 情况3 [root@VM-0-14-centos mysql]# rpm -ivh mysql-community-test-8.0.26-1.el7.x86_64.rpm warning: mysql-community-test-8.0.26-1.el7.x86_64.rpm: Header V3 DSA/SHA256 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies: perl(Data::Dumper) is needed by mysql-community-test-8.0.26-1.el7.x86_64\n解决方式\nyum -y install autoconf 情况4 [root@VM-0-14-centos mysql]# rpm -ivh mysql-community-test-8.0.26-1.el7.x86_64.rpm warning: mysql-community-test-8.0.26-1.el7.x86_64.rpm: Header V3 DSA/SHA256 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies: perl(JSON) is needed by mysql-community-test-8.0.26-1.el7.x86_64\n解决方式\nyum install perl-JSON.noarch -y yum install perl.x86_64 perl-devel.x86_64 -y 情况5 [root@VM-0-14-centos mysql]# rpm -ivh mysql-community-test-8.0.26-1.el7.x86_64.rpm warning: mysql-community-test-8.0.26-1.el7.x86_64.rpm: Header V3 DSA/SHA256 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies: perl(Test::More) is needed by mysql-community-test-8.0.26-1.el7.x86_64\n解决方式：\n到 https://pkgs.org/download/perl(Test::More)，打开centos7的下拉框，找到CentOS x86_64下对应的rpm，然后打开这个rpm连接，在Download对应的部分找Binary Package，后面有对应的rpm下载连接，下载下来进行安装即可 9、初始化数据库\nmysqld \u0026ndash;initialize \u0026ndash;console\n10、目录授权，否则可能会启动失败\nchown -R mysql:mysql /var/lib/mysql/\n11、启动mysql\nsystemctl start mysqld\n对应的重启、关闭mysql命令如下 systemctl stop mysqld systemctl restart mysqld\n12、查询mysql状态\nsystemctl status mysqld\n13、查询mysql的临时密码\ncat /var/log/mysqld.log | grep password\n14、使用临时密码登录mysql\nmysql -u root -p\n注意：linux下输入密码是不会回显（不是电脑坏了！），输入完毕后直接回车即可 密码输入正确，回车后看到如下信息，则代表成功进入mysql 15、修改mysql的登录密码\nalter user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; identified with mysql_native_password by \u0026lsquo;你的密码\u0026rsquo; ;\n注：mysql8对密码的强度有很高的要求，具体密码要求可使用以下命令查询 SHOW VARIABLES LIKE \u0026lsquo;validate_password%\u0026rsquo;;\n最后重启下mysql即可\n16、mysql设置远程连接 注：这个步骤根据实际需求而设定\nshow databases ; use mysql ;\n查看可登录mysql的host\nselect host, user from user;\nhost部分全部都是localhost，说明用户只能本地连接msyql服务 修改root用户的host值，并刷新mysql数据库 update user set user.host=\u0026rsquo;%\u0026rsquo; where user.user=\u0026lsquo;root\u0026rsquo;; flush privileges;\n在我的windows电脑上使用Navicat测试连接服务器上的mysql，看看是否能够远程连接 17、其他情况说明\n连接失败的情况\ncentos7的防火墙是否开启了3306的端口 云服务器的出入站规则配置情况 篇幅太长这里不再一一说明情况，如果遇到失败情况请自行查询\n","date":"2021-07-27T21:06:14+08:00","image":"https://dxjxpr.github.io/p/centos7%E5%AE%89%E8%A3%85mysql8%E6%95%99%E7%A8%8B/mysql_hu_5d2b80aeec835d63.jpg","permalink":"https://dxjxpr.github.io/p/centos7%E5%AE%89%E8%A3%85mysql8%E6%95%99%E7%A8%8B/","title":"CentOS7安装mysql8教程"},{"content":" 缘起缘灭缘自在，情深情浅不由人，世人皆各有各的渡口，各有各的归舟，山水一程，人各有命\n人生不过是一段旅程，如同穿越山水。我们试图留住想留的，带走想带的，却终究难以实现。尝遍人间的酸甜苦辣，经历悲欢离合，当一切落幕，生命也走到了尽头\n人们常问，一生追求的钱、权、名望，究竟何为真正拥有？其实，这些都不是。我们所得到的只是暂时的使用权，而失去的，也从来真正属于我们\n短短几十年的人生，痛苦并非来自生活本身，而是源于我们的执着和不舍。人间暂坐，何必苦苦执着\n借一副皮囊，游戏人间，品味百态，又是一生。时光荏苒，该散的终将散去，该走的注定要走。最终空空如也，既无你，也无我\n本是修行之人，却因红尘中的浊酒而流连忘返。世间情感难以割舍，真心付出，望穿秋水。碎银几两，虽能解万千忧愁，却让人跪地捡拾，起早贪黑，如同牛马。 然而到头来，金钱带不走，情感留不住。一切的一切，都归结为造化弄人\n缘分来了就相聚，缘分尽了就散场。不强求他人，不为难自己。一切早有定数，当那天到来时，我们只需平静接受便好\n生活中的每一天，都是一次命运的邂逅。或许有时，我们会因为错过而懊悔，因为失去而痛苦，但请相信，每一次的失落都是为了更好的遇见\n在这漫长的旅程中，我们会遇见形形色色的人。有的人，如流星划过天际，短暂而耀眼；有的人，如久旱逢甘露，给予我们无尽的温暖和力量。无论遇见谁，都是生命中不可或缺的章节，他们教会我们成长，教会我们爱\n爱情，是人生中最美妙的奇迹。它让我们在茫茫人海中找到了彼此，愿意为对方付出一切。但请记住，爱情不是生活的全部，我们还有亲情、友情和自我。在追求爱情的同时，也不要忘了关爱自己，珍惜身边的每一个人\n随着岁月的流逝，我们会逐渐明白，人生最宝贵的财富并非金钱和地位，而是那些无法用金钱衡量的东西：健康的身体、和睦的家庭、真挚的友谊以及内心的平静和满足。当我们拥有这些时，即使生活再平凡，也能感受到幸福和温暖\n在未来的日子里，愿我们都能珍惜当下，拥抱生活，用一颗感恩的去面对一切。无论前方有多少困难和挑战，只要我们心中有爱，就有勇气去迎接每一个新的黎明\n事当快意处须转，言到快意处须往\n临事须替别人想，论人先将自己想\n人褊急，我受之以宽宏；人险仄，我待之以坦荡\n缓字可以免悔，退字可以免祸\n不尽人情，举足尽是危机；不体物情，一生俱成梦境\n一念疏忽是错起头，一念决裂是错到底\n世界是个回音谷，念念不忘必有回响，你大声喊唱，山谷雷响，音传千里\n不要赌天意，不要测人心，天意你赌不起，人心你猜不透\n凡是劝不动的，拦不住的，那就是命\n我不认识你，因为我没有眼睛。然而，如果你损害我的幸福，我将永远不让你亲近我的内心\n长亭外，古道边，芳草碧连天。问君此去几时还，来时莫徘徊\n人生最忌讳的就是圆满，求缺不求满\n","date":"2020-08-23T12:00:00+08:00","image":"https://dxjxpr.github.io/p/%E4%BA%BA%E7%94%9F%E8%AF%AD%E5%BD%95%E4%B8%93%E8%BE%91/cover_hu_feec134d16639fcb.jpg","permalink":"https://dxjxpr.github.io/p/%E4%BA%BA%E7%94%9F%E8%AF%AD%E5%BD%95%E4%B8%93%E8%BE%91/","title":"人生语录专辑"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://dxjxpr.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://dxjxpr.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"下载并安装Navicat15 1、到Navicat官网下载Navicat Premium 15版本 然后一直下一步 点击安装 激活Navicat15 1、使用navicat15激活工具（激活工具链接见文章末尾） 双击Navicat Keygen Patch v5.6.0 DFoX.exe，出现如下弹框 2、点击Patch按钮 3、出现如下提示窗口，则证明该步骤ok。如果点击Patch按钮后，弹出了资源管理器，在弹出的资源管理器中找到navicat的安装目录，并双击navicat.exe，然后即可看到如下的提示信息 4、按照如图所示，点击Generate按钮，然后会生成一个密钥，复制这个密钥 5、打开Navicat软件 6、将刚才复制的密钥直接粘贴到这里 7、点击手动激活 8、复制请求码 9、按照如下图所示，进行粘贴激活 ","date":"2018-10-09T15:44:34+08:00","image":"https://dxjxpr.github.io/p/navicat15%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/navicat_hu_f559e0bf1c9bfd40.png","permalink":"https://dxjxpr.github.io/p/navicat15%E6%BF%80%E6%B4%BB%E6%95%99%E7%A8%8B/","title":"Navicat15激活教程"},{"content":"友情提示：数据无价，谨慎操作（会出事的） 看完再进行操作，如果是新手最好有人在旁边指导！！！ 看完再进行操作，如果是新手最好有人在旁边指导！！！ 看完再进行操作，如果是新手最好有人在旁边指导！！！ 重要的事情说三遍\t！！！ 重装系统 如果你还需要的话，请先将系统所要安装到的分区数据备份出来，后面会格式化该分区（删除）\n系统盘刻录好之后，就要进入电脑的BIOS界面了，U盘插上之后，就不要去动了，直到系统装好之后再拔掉，如何进入BIOS？在你电脑开机（重启/开机），出现电脑图标的时候，按下BIOS快捷键，常见BIOS的快捷键有DEL、ESC、F2、F10、F11、F12，可根据自己的电脑品牌在网上搜下 比如联想的，等出现下面的图标后按下联想的BIOS快捷键，其他牌子的电脑类比下 然后进入到下面的蓝色页面，这是我电脑的BIOS，每个电脑的BIOS界面可能不太一样，比如Dell新版BIOS是白色的文字页面，了解下就行（问题不大，找到系统启动顺序就行，BIOS里面会有说明信息），我这里是通过上下左右按键来移动，使用enter还确认，使用esc来退出，在boot菜单下，选择系统启动方式，还记得上面说的mbr+legacy模式（旧）和gpt+uefi模式（新）吗？看到下面的U盘选项前面有个UEFI了吗，因为我电脑磁盘分区表格式是gpt格式的，所以就选择uefi启动，如果是mbr的话，找到前面不带uefi的U盘选项（注：我这里没有那个选项）；有的电脑主板是会有单独的启动方式选项，然后根据磁盘分区表来选择legacy还是uefi方式即可，具体情况需要看你电脑的主板了。\n然后将U盘调整到第一个选项，有的是使用+/-，有的是使用F5/F6来调整，具体需要看你的BIOS怎么调整，一般来说右边会有英文说明，我这里是使用回车来调整，最后按下F10保存BIOS设置（注一般是F10，有的电脑不是） F10保存并退出BIOS 第二种进入U盘的方式是先进入到BIOS的菜单选项，再找到U盘启动项，直接回车就行了，然后就是等着重启了，看到没有？我这里有两个U盘选项，一个不带UEFI的（搭配mbr分区表格式），一个带（搭配gpt分区表格式），我这里肯定是选择带UEFI的选项了（因为我电脑磁盘的分区表格式是gpt呀！），你需要根据你电脑磁盘分区表格式来选择了，哈？不知道自己电脑分区表格式？请看这里 然后读取U盘信息，进入系统盘 很好，已经进来了，下面的界面选择默认，直接点击下一步即可 点击现在安装 安装程序正在启动，等待几秒就好了 这里要输入密钥，选择下方的选项：我没有密钥，先跳过这一步，装好系统后再来激活 win10的系统镜像一般包含好几种系统版本来供选择，看自己选择，我这里选择专业版 签订协议，点击下一步继续 注意：这里涉及到磁盘了！！！谨慎操作！！！不小心的话会把磁盘里的文件删了，搞明白了再进行操作\n因为我们要重装系统，所以选择第二个自定义选项，自己来设置系统磁盘的大小 点击自定义后会出现你现在电脑上所有的分区（下图)\n这里很重要！！！很重要！！！很重要！！！看清楚再点击！！！ 先说下系统磁盘的大小划分，一般来说系统会占用掉30G左右的磁盘空间，然后肯定不能只分30G，因为系统需要安装各种软件，而有的软件是只能安装到C盘的（系统盘），比如说谷歌浏览器什么的，所以一般就给系统分60G往上，当然你磁盘空间大的话，可以多划分，这个具体如何划分需要根据磁盘大小和你电脑用途来选择\n因为我这里有两块磁盘，所以上面会显示两个驱动器号（0和1），同一个驱动号可能有多个分区，就是你windows上显示的C、D、E\u0026hellip;.盘，在我电脑里驱动器0代表的是机械硬盘，驱动器1代表的是固态硬盘，注意如果你也有多块硬盘的话，驱动器0不一定代表的是机械硬盘，具体代表的是什么硬盘是和你电脑硬盘的安装顺序有关系，这里要看清楚再选择！！！别搞错了！！！\n在这里 我想将系统装在固态硬盘当中，那么我就去对带驱动器1的分区进行操作，选择好你要安装的地方，然后将这块分区删除，如果电脑里面没有其他系统的话，或者没有必要的话，将该窗口上显示的msr分区、esp分区、恢复分区都给删除了，删除后，该窗口上会出现一个名为： “未分区的空间 ” 的分区，如果你电脑本身就有未分区的空间，那么在你进行删除之后，可能会和你电脑本来就有的 未分区空间 合并到一起（ 至于是否合并与物理磁盘顺序有关），这个注意下，然后点击该未分区的空间，显示成高亮之后，点击下一步，然后就是开始安装系统了\n注：如果该步骤在点击下一步的时候提示安装不了系统，可能是系统的原因，也有可能是磁盘的原因，或者是系统启动方式错误等其他错误原因，如果遇到问题请自行百度，这里只讲日常（正常）操作！！！ 下面这个步骤就需要等待了，时间长短不一，一般几分钟就好了，这个时候就不用管了，等着它安装好就行了 注：此时不要强制关机 安装好之后就会有下面的界面，你可以选择等10秒钟自动重启，或者是点击立即重启，等电脑黑屏之后，将U盘拔掉，不要拔早了，可能会造成系统损坏（会安装失败的）；也不要迟拔，因为迟拔的话，可能还会进入到安装界面，因为U盘设置的是第一启动项！！！如果是迟拔的话，将那个安装页面关了，把U盘拔掉就行 U盘拔掉之后，就等着它重启，注：这个过程，电脑可能会启动多次，正常操作，不用担心，下面就是根据系统提示信息来进行操作了 下面的密钥依旧选择跳过，选择以后再说，如果提示联网的话，不要联网！不要联网！不要联网！网线拔了，也不要去连接WiFi，把网断掉 这个可以选择自定义，或者是默认的设置，看个人喜好，这里选择的是默认设置 下面就是创建账户了，如果不想创建账户，直接点击下一步，系统默认的账户是Administrator（管理员），或者是你只想创建一个账户而不设置密码的话，就输入一个账户名字就行了，然后点击下一步，这样就没有密码了 下面就是系统自己的事情了，会进行一系列的配置 等待后的结果就是下面这个样子。是不是感觉很纯净？这样系统就算是装好了，接着就需要自己进行系统的配置了，比如屏幕分辨率、个性化、磁盘划分、安装各种软件等等，所以装系统并不费时间，费时间的是装好后的操作 ","date":"2018-10-08T19:57:34+08:00","image":"https://dxjxpr.github.io/p/u%E7%9B%98%E9%87%8D%E8%A3%85win10%E4%B8%89%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/windows10_03_hu_cb6495904e9df50a.jpg","permalink":"https://dxjxpr.github.io/p/u%E7%9B%98%E9%87%8D%E8%A3%85win10%E4%B8%89%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/","title":"U盘重装win10(三)重装系统"},{"content":"刻录系统 使用刻录工具，这里用的是UltraISO（软碟通）官网下载，或者使用其他刻录软件\n注：这个软件下载好之后，可以不用激活，直接点右下角的继续试用就行，如果想激活的话，附激活账号： 用户名：王涛 注册码：7C81-1689-4046-626F\n先将U盘中的数据备份出来，后面要格式化U盘 启动ultraISO 选择系统镜像 这样系统就加载到ultraISO里了 然后选择刻录（写入硬盘映像） 这里选择你所要刻录的U盘（会显示你U盘的名字，我U盘是金士顿，所以上面的名字是Kingston），刻录校验可选可不选 然后把根据图片提示步骤，先将U盘格式化，再选择写入，如果是3.0的U盘的话，一般小于10分钟，如果是2.0的话，可能会稍微久一点，这个对装系统没什么影响 然后就是开始刻录，刻录过程不要动U盘，否则可能会造成系统的刻录失败（ultraISO可能会提醒可能不会） 刻录好的U盘内容，看到U盘的名字变成了CCCOMA_X64F了没？刻录系统会改变U盘的名字，所以上面在格式化U盘的时候，U盘的名字不用换，但需要一个名字 下面就是开始装系统了\n","date":"2018-10-07T21:47:48+08:00","image":"https://dxjxpr.github.io/p/u%E7%9B%98%E9%87%8D%E8%A3%85win10%E4%BA%8C%E5%88%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%E7%9B%98/windows10_02_hu_43ba16cd19cdae82.jpg","permalink":"https://dxjxpr.github.io/p/u%E7%9B%98%E9%87%8D%E8%A3%85win10%E4%BA%8C%E5%88%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%E7%9B%98/","title":"U盘重装win10(二)刻录系统盘"},{"content":"装系统准备： 一个不小于8G的U盘 一个下载好的win10系统镜像（后缀式为.iso） 下载工具：迅雷或者百度云盘 刻录工具：UltraISO（软碟通，最好是从官网下载），或者其他刻录软件 磁盘工具：diskgenius，或其他磁盘工具都可以\n检查电脑参数 首先需要去知道自己电脑里面的一些参数，这里用DiskGenius软件来检测，需要可到官网下载 以我电脑为例，我电脑是64位的，所以这里下载的是64位，根据自己电脑来选择 上面的分区表类型很重要！后面装的时候用的到\n如果你所要装系统磁盘的分区表格式是mbr，那么在重装系统的时候方式就要选择legacy 如果是上面的gpt格式，那么启动方式就选择uefi 不要搞错了，如果不匹配的话，可能装不上系统，或者装上了以后在更新系统的时候，系统是更新不了的，这里先这么选，不懂也没事，不要搞错就行了 下面看看就行，如果会的话，可以绕过，关乎数据安全！（数据无价，谨慎操作！！！） 附加：mbr+legacy模式（旧）是传统启动方式，相对于gpt+uefi模式（新），系统启动时间可能相对慢点，还有磁盘的主分区数量 等其他的区别。 如果想转换的话，可以在重装系统选择磁盘界面可以转换（具体操作请百度），警告：要转换的磁盘会被格式化，这里的格式化是整个磁盘，不是某个分区！！！数据会全部丢失！！！\n下载系统镜像 百度msdn，从这个网站下载镜像系统 注：这个网站不仅有各种系统镜像，还有其他微软的软件，比如vb、vs、office等等，有需要可以从这里下载，下载方式和下载系统镜像一样一样的 这里的操作系统有win7、win8、win8.1、win10等等 可以使用迅雷来下载系统镜像，只需要复制下载链接后打开迅雷，就会自动弹出下载页面了，选择你要存放的位置 如果不想用迅雷的话，也可以用百度云盘（这个我想都应该有的吧？） 复制下载链接后，选择离线下载，保存到百度网盘上，然后再下载下来 系统镜像已经有了，那么下面就是把U盘插电脑上，开始刻系统盘了\n","date":"2018-10-06T19:57:34+08:00","image":"https://dxjxpr.github.io/p/u%E7%9B%98%E9%87%8D%E8%A3%85win10%E4%B8%80%E4%B8%8B%E8%BD%BD%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/windows10_01_hu_ca53c39a96462688.jpeg","permalink":"https://dxjxpr.github.io/p/u%E7%9B%98%E9%87%8D%E8%A3%85win10%E4%B8%80%E4%B8%8B%E8%BD%BD%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/","title":"U盘重装win10(一)下载系统镜像"}]